/* eslint-disable */
/* tslint:disable */
/**
 * This is an autogenerated file created by the Stencil compiler.
 * It contains typing information for all components that exist in this project.
 */
import { HTMLStencilElement, JSXBase } from "@stencil/core/internal";
import { AccordionReturn, AlertVariant, DrawerPlacement, TabsReturn, ToastType, TooltipPlacement } from "@andersseen/headless-components";
import { ButtonProps } from "./components/and-button/and-button";
import { DropdownItem } from "./components/and-dropdown/and-dropdown";
import { IconName } from "@andersseen/icon";
import { NavbarProps, NavItem } from "./components/and-navbar/and-navbar";
import { SidebarItem, SidebarProps } from "./components/and-sidebar/and-sidebar";
export { AccordionReturn, AlertVariant, DrawerPlacement, TabsReturn, ToastType, TooltipPlacement } from "@andersseen/headless-components";
export { ButtonProps } from "./components/and-button/and-button";
export { DropdownItem } from "./components/and-dropdown/and-dropdown";
export { IconName } from "@andersseen/icon";
export { NavbarProps, NavItem } from "./components/and-navbar/and-navbar";
export { SidebarItem, SidebarProps } from "./components/and-sidebar/and-sidebar";
export namespace Components {
    /**
     * Accordion container component using headless logic
     * @example ```html
     * <and-accordion allow-multiple="true">
     *   <and-accordion-item value="item-1">
     *     <and-accordion-trigger>Item 1</and-accordion-trigger>
     *     <and-accordion-content>Content 1</and-accordion-content>
     *   </and-accordion-item>
     * </and-accordion>
     * ```
     */
    interface AndAccordion {
        /**
          * Allow multiple items to be expanded simultaneously
          * @default false
         */
        "allowMultiple": boolean;
        /**
          * Default expanded item values
         */
        "defaultValue"?: string[];
        /**
          * Whether the accordion is disabled
          * @default false
         */
        "disabled": boolean;
        /**
          * Orientation of the accordion
          * @default 'vertical'
         */
        "orientation": 'horizontal' | 'vertical';
    }
    /**
     * Accordion content/panel component
     */
    interface AndAccordionContent {
        /**
          * Set item properties from parent
         */
        "setItemProps": (props: { itemId: string; accordionLogic: AccordionReturn; }) => Promise<void>;
    }
    /**
     * Accordion item component
     */
    interface AndAccordionItem {
        /**
          * Whether this item is disabled
          * @default false
         */
        "disabled": boolean;
        /**
          * Method for parent to pass accordion logic
         */
        "setAccordionLogic": (logic: AccordionReturn) => Promise<void>;
        /**
          * Unique value for this accordion item
         */
        "value": string;
    }
    /**
     * Accordion trigger/header component
     */
    interface AndAccordionTrigger {
        /**
          * Set item properties from parent
         */
        "setItemProps": (props: { itemId: string; accordionLogic: AccordionReturn; disabled?: boolean; }) => Promise<void>;
    }
    interface AndAlert {
        /**
          * @default false
         */
        "dismissible": boolean;
        /**
          * @default 'default'
         */
        "variant": AlertVariant;
    }
    interface AndBadge {
        /**
          * @default 'default'
         */
        "variant": 'default' | 'secondary' | 'destructive' | 'outline';
    }
    interface AndButton {
        "customClass": string;
        /**
          * @default false
         */
        "disabled": boolean;
        /**
          * @default false
         */
        "loading": boolean;
        /**
          * @default 'default'
         */
        "size": ButtonProps['size'];
        /**
          * @default 'button'
         */
        "type": 'button' | 'submit' | 'reset';
        /**
          * @default 'default'
         */
        "variant": ButtonProps['variant'];
    }
    interface AndCard {
        /**
          * @default 'default'
         */
        "variant": 'default' | 'destructive';
    }
    interface AndCarousel {
        /**
          * @default false
         */
        "autoplay": boolean;
        /**
          * @default 3000
         */
        "interval": number;
    }
    interface AndCarouselItem {
    }
    interface AndDrawer {
        /**
          * Whether the drawer is open.
          * @default false
         */
        "open": boolean;
        /**
          * The direction the drawer slides in from.
          * @default 'left'
         */
        "placement": DrawerPlacement;
        /**
          * Whether to show the default close button in the header.
          * @default true
         */
        "showClose": boolean;
    }
    interface AndDropdown {
        /**
          * @default true
         */
        "closeOnSelect": boolean;
        /**
          * @default []
         */
        "items": DropdownItem[];
        /**
          * @default 'Options'
         */
        "label": string;
        /**
          * @default 'bottom'
         */
        "placement": 'top' | 'bottom' | 'left' | 'right';
        /**
          * @default 'default'
         */
        "variant": any;
    }
    interface AndIcon {
        /**
          * The color of the icon (default: currentColor)
          * @default 'currentColor'
         */
        "color": string;
        /**
          * The name of the icon to render. Must be previously registered via `registerIcons()`.
         */
        "name": IconName;
        /**
          * The size of the icon in pixels (default: 24)
          * @default 24
         */
        "size": string | number;
        /**
          * Stroke width (default: 2)
          * @default 2
         */
        "strokeWidth": string | number;
    }
    interface AndInput {
        "class": string;
        /**
          * @default false
         */
        "disabled": boolean;
        "placeholder": string;
        /**
          * @default 'text'
         */
        "type": string;
        "value": string;
    }
    interface AndModal {
        /**
          * @default false
         */
        "open": boolean;
    }
    interface AndNavbar {
        /**
          * The active navigation item ID. Reflects the headless‐core state.
          * @default ''
         */
        "activeItem": string;
        /**
          * ARIA label for the navigation
          * @default 'Main navigation'
         */
        "ariaNavLabel": string;
        /**
          * Navigation items to display. When provided, the component renders its own items (with full keyboard navigation, scroll-spy, and active‐indicator). When empty, use the `nav` slot for custom content.
          * @default []
         */
        "items": NavItem[] | string;
        /**
          * Positioning behaviour
          * @default 'static'
         */
        "position": 'static' | 'sticky' | 'fixed';
        /**
          * Enable scroll-spy (auto-detect active section by scroll position). Items must have `href` starting with `#`.
          * @default false
         */
        "scrollSpy": boolean;
        /**
          * Scroll-spy offset from the top of viewport (px).
          * @default 100
         */
        "scrollSpyOffset": number;
        /**
          * Visual variant
          * @default 'default'
         */
        "variant": NavbarProps['variant'];
    }
    interface AndPagination {
        /**
          * current page number
          * @default 1
         */
        "currentPage": number;
        /**
          * total number of pages
          * @default 1
         */
        "totalPages": number;
    }
    interface AndSidebar {
        /**
          * The active navigation item ID
          * @default 'home'
         */
        "activeItem": string;
        /**
          * Whether the sidebar is collapsed
          * @default false
         */
        "collapsed": boolean;
        /**
          * Navigation items to display
          * @default [     { id: 'home', label: 'Home' },     { id: 'docs', label: 'Docs' },     { id: 'components', label: 'Components' },   ]
         */
        "items": SidebarItem[];
        /**
          * Variant of the sidebar
          * @default 'default'
         */
        "variant": SidebarProps['variant'];
    }
    interface AndTabs {
        /**
          * @default 'automatic'
         */
        "activationMode": 'automatic' | 'manual';
        "defaultValue": string;
        /**
          * @default 'horizontal'
         */
        "orientation": 'horizontal' | 'vertical';
        "value": string;
    }
    interface AndTabsContent {
        /**
          * @default false
         */
        "selected": boolean;
        "value": string;
    }
    interface AndTabsList {
        /**
          * @default 'horizontal'
         */
        "orientation": 'horizontal' | 'vertical';
    }
    interface AndTabsTrigger {
        /**
          * @default false
         */
        "disabled": boolean;
        /**
          * @default false
         */
        "selected": boolean;
        "tabsLogic": TabsReturn;
        "value": string;
    }
    interface AndToast {
        /**
          * Present a new toast
         */
        "present": (message: string, type?: ToastType, duration?: number) => Promise<any>;
    }
    interface AndTooltip {
        /**
          * @default 0
         */
        "closeDelay": number;
        "content": string;
        /**
          * @default 0
         */
        "openDelay": number;
        /**
          * @default 'top'
         */
        "placement": TooltipPlacement;
    }
}
export interface AndAlertCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLAndAlertElement;
}
export interface AndDrawerCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLAndDrawerElement;
}
export interface AndDropdownCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLAndDropdownElement;
}
export interface AndInputCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLAndInputElement;
}
export interface AndModalCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLAndModalElement;
}
export interface AndNavbarCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLAndNavbarElement;
}
export interface AndPaginationCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLAndPaginationElement;
}
export interface AndSidebarCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLAndSidebarElement;
}
export interface AndTabsCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLAndTabsElement;
}
export interface AndTabsTriggerCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLAndTabsTriggerElement;
}
declare global {
    /**
     * Accordion container component using headless logic
     * @example ```html
     * <and-accordion allow-multiple="true">
     *   <and-accordion-item value="item-1">
     *     <and-accordion-trigger>Item 1</and-accordion-trigger>
     *     <and-accordion-content>Content 1</and-accordion-content>
     *   </and-accordion-item>
     * </and-accordion>
     * ```
     */
    interface HTMLAndAccordionElement extends Components.AndAccordion, HTMLStencilElement {
    }
    var HTMLAndAccordionElement: {
        prototype: HTMLAndAccordionElement;
        new (): HTMLAndAccordionElement;
    };
    /**
     * Accordion content/panel component
     */
    interface HTMLAndAccordionContentElement extends Components.AndAccordionContent, HTMLStencilElement {
    }
    var HTMLAndAccordionContentElement: {
        prototype: HTMLAndAccordionContentElement;
        new (): HTMLAndAccordionContentElement;
    };
    /**
     * Accordion item component
     */
    interface HTMLAndAccordionItemElement extends Components.AndAccordionItem, HTMLStencilElement {
    }
    var HTMLAndAccordionItemElement: {
        prototype: HTMLAndAccordionItemElement;
        new (): HTMLAndAccordionItemElement;
    };
    /**
     * Accordion trigger/header component
     */
    interface HTMLAndAccordionTriggerElement extends Components.AndAccordionTrigger, HTMLStencilElement {
    }
    var HTMLAndAccordionTriggerElement: {
        prototype: HTMLAndAccordionTriggerElement;
        new (): HTMLAndAccordionTriggerElement;
    };
    interface HTMLAndAlertElementEventMap {
        "myDismiss": void;
    }
    interface HTMLAndAlertElement extends Components.AndAlert, HTMLStencilElement {
        addEventListener<K extends keyof HTMLAndAlertElementEventMap>(type: K, listener: (this: HTMLAndAlertElement, ev: AndAlertCustomEvent<HTMLAndAlertElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLAndAlertElementEventMap>(type: K, listener: (this: HTMLAndAlertElement, ev: AndAlertCustomEvent<HTMLAndAlertElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLAndAlertElement: {
        prototype: HTMLAndAlertElement;
        new (): HTMLAndAlertElement;
    };
    interface HTMLAndBadgeElement extends Components.AndBadge, HTMLStencilElement {
    }
    var HTMLAndBadgeElement: {
        prototype: HTMLAndBadgeElement;
        new (): HTMLAndBadgeElement;
    };
    interface HTMLAndButtonElement extends Components.AndButton, HTMLStencilElement {
    }
    var HTMLAndButtonElement: {
        prototype: HTMLAndButtonElement;
        new (): HTMLAndButtonElement;
    };
    interface HTMLAndCardElement extends Components.AndCard, HTMLStencilElement {
    }
    var HTMLAndCardElement: {
        prototype: HTMLAndCardElement;
        new (): HTMLAndCardElement;
    };
    interface HTMLAndCarouselElement extends Components.AndCarousel, HTMLStencilElement {
    }
    var HTMLAndCarouselElement: {
        prototype: HTMLAndCarouselElement;
        new (): HTMLAndCarouselElement;
    };
    interface HTMLAndCarouselItemElement extends Components.AndCarouselItem, HTMLStencilElement {
    }
    var HTMLAndCarouselItemElement: {
        prototype: HTMLAndCarouselItemElement;
        new (): HTMLAndCarouselItemElement;
    };
    interface HTMLAndDrawerElementEventMap {
        "myClose": void;
        "myOpen": void;
    }
    interface HTMLAndDrawerElement extends Components.AndDrawer, HTMLStencilElement {
        addEventListener<K extends keyof HTMLAndDrawerElementEventMap>(type: K, listener: (this: HTMLAndDrawerElement, ev: AndDrawerCustomEvent<HTMLAndDrawerElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLAndDrawerElementEventMap>(type: K, listener: (this: HTMLAndDrawerElement, ev: AndDrawerCustomEvent<HTMLAndDrawerElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLAndDrawerElement: {
        prototype: HTMLAndDrawerElement;
        new (): HTMLAndDrawerElement;
    };
    interface HTMLAndDropdownElementEventMap {
        "dropdownSelect": string;
    }
    interface HTMLAndDropdownElement extends Components.AndDropdown, HTMLStencilElement {
        addEventListener<K extends keyof HTMLAndDropdownElementEventMap>(type: K, listener: (this: HTMLAndDropdownElement, ev: AndDropdownCustomEvent<HTMLAndDropdownElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLAndDropdownElementEventMap>(type: K, listener: (this: HTMLAndDropdownElement, ev: AndDropdownCustomEvent<HTMLAndDropdownElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLAndDropdownElement: {
        prototype: HTMLAndDropdownElement;
        new (): HTMLAndDropdownElement;
    };
    interface HTMLAndIconElement extends Components.AndIcon, HTMLStencilElement {
    }
    var HTMLAndIconElement: {
        prototype: HTMLAndIconElement;
        new (): HTMLAndIconElement;
    };
    interface HTMLAndInputElementEventMap {
        "myInput": string;
    }
    interface HTMLAndInputElement extends Components.AndInput, HTMLStencilElement {
        addEventListener<K extends keyof HTMLAndInputElementEventMap>(type: K, listener: (this: HTMLAndInputElement, ev: AndInputCustomEvent<HTMLAndInputElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLAndInputElementEventMap>(type: K, listener: (this: HTMLAndInputElement, ev: AndInputCustomEvent<HTMLAndInputElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLAndInputElement: {
        prototype: HTMLAndInputElement;
        new (): HTMLAndInputElement;
    };
    interface HTMLAndModalElementEventMap {
        "myClose": void;
    }
    interface HTMLAndModalElement extends Components.AndModal, HTMLStencilElement {
        addEventListener<K extends keyof HTMLAndModalElementEventMap>(type: K, listener: (this: HTMLAndModalElement, ev: AndModalCustomEvent<HTMLAndModalElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLAndModalElementEventMap>(type: K, listener: (this: HTMLAndModalElement, ev: AndModalCustomEvent<HTMLAndModalElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLAndModalElement: {
        prototype: HTMLAndModalElement;
        new (): HTMLAndModalElement;
    };
    interface HTMLAndNavbarElementEventMap {
        "navItemClick": string;
        "navLinkClick": { id: string; href: string };
        "mobileMenuChange": boolean;
    }
    interface HTMLAndNavbarElement extends Components.AndNavbar, HTMLStencilElement {
        addEventListener<K extends keyof HTMLAndNavbarElementEventMap>(type: K, listener: (this: HTMLAndNavbarElement, ev: AndNavbarCustomEvent<HTMLAndNavbarElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLAndNavbarElementEventMap>(type: K, listener: (this: HTMLAndNavbarElement, ev: AndNavbarCustomEvent<HTMLAndNavbarElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLAndNavbarElement: {
        prototype: HTMLAndNavbarElement;
        new (): HTMLAndNavbarElement;
    };
    interface HTMLAndPaginationElementEventMap {
        "pageChange": number;
    }
    interface HTMLAndPaginationElement extends Components.AndPagination, HTMLStencilElement {
        addEventListener<K extends keyof HTMLAndPaginationElementEventMap>(type: K, listener: (this: HTMLAndPaginationElement, ev: AndPaginationCustomEvent<HTMLAndPaginationElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLAndPaginationElementEventMap>(type: K, listener: (this: HTMLAndPaginationElement, ev: AndPaginationCustomEvent<HTMLAndPaginationElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLAndPaginationElement: {
        prototype: HTMLAndPaginationElement;
        new (): HTMLAndPaginationElement;
    };
    interface HTMLAndSidebarElementEventMap {
        "sidebarItemClick": string;
        "sidebarToggle": boolean;
    }
    interface HTMLAndSidebarElement extends Components.AndSidebar, HTMLStencilElement {
        addEventListener<K extends keyof HTMLAndSidebarElementEventMap>(type: K, listener: (this: HTMLAndSidebarElement, ev: AndSidebarCustomEvent<HTMLAndSidebarElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLAndSidebarElementEventMap>(type: K, listener: (this: HTMLAndSidebarElement, ev: AndSidebarCustomEvent<HTMLAndSidebarElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLAndSidebarElement: {
        prototype: HTMLAndSidebarElement;
        new (): HTMLAndSidebarElement;
    };
    interface HTMLAndTabsElementEventMap {
        "valueChange": string;
    }
    interface HTMLAndTabsElement extends Components.AndTabs, HTMLStencilElement {
        addEventListener<K extends keyof HTMLAndTabsElementEventMap>(type: K, listener: (this: HTMLAndTabsElement, ev: AndTabsCustomEvent<HTMLAndTabsElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLAndTabsElementEventMap>(type: K, listener: (this: HTMLAndTabsElement, ev: AndTabsCustomEvent<HTMLAndTabsElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLAndTabsElement: {
        prototype: HTMLAndTabsElement;
        new (): HTMLAndTabsElement;
    };
    interface HTMLAndTabsContentElement extends Components.AndTabsContent, HTMLStencilElement {
    }
    var HTMLAndTabsContentElement: {
        prototype: HTMLAndTabsContentElement;
        new (): HTMLAndTabsContentElement;
    };
    interface HTMLAndTabsListElement extends Components.AndTabsList, HTMLStencilElement {
    }
    var HTMLAndTabsListElement: {
        prototype: HTMLAndTabsListElement;
        new (): HTMLAndTabsListElement;
    };
    interface HTMLAndTabsTriggerElementEventMap {
        "tabTriggerClick": string;
    }
    interface HTMLAndTabsTriggerElement extends Components.AndTabsTrigger, HTMLStencilElement {
        addEventListener<K extends keyof HTMLAndTabsTriggerElementEventMap>(type: K, listener: (this: HTMLAndTabsTriggerElement, ev: AndTabsTriggerCustomEvent<HTMLAndTabsTriggerElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLAndTabsTriggerElementEventMap>(type: K, listener: (this: HTMLAndTabsTriggerElement, ev: AndTabsTriggerCustomEvent<HTMLAndTabsTriggerElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLAndTabsTriggerElement: {
        prototype: HTMLAndTabsTriggerElement;
        new (): HTMLAndTabsTriggerElement;
    };
    interface HTMLAndToastElement extends Components.AndToast, HTMLStencilElement {
    }
    var HTMLAndToastElement: {
        prototype: HTMLAndToastElement;
        new (): HTMLAndToastElement;
    };
    interface HTMLAndTooltipElement extends Components.AndTooltip, HTMLStencilElement {
    }
    var HTMLAndTooltipElement: {
        prototype: HTMLAndTooltipElement;
        new (): HTMLAndTooltipElement;
    };
    interface HTMLElementTagNameMap {
        "and-accordion": HTMLAndAccordionElement;
        "and-accordion-content": HTMLAndAccordionContentElement;
        "and-accordion-item": HTMLAndAccordionItemElement;
        "and-accordion-trigger": HTMLAndAccordionTriggerElement;
        "and-alert": HTMLAndAlertElement;
        "and-badge": HTMLAndBadgeElement;
        "and-button": HTMLAndButtonElement;
        "and-card": HTMLAndCardElement;
        "and-carousel": HTMLAndCarouselElement;
        "and-carousel-item": HTMLAndCarouselItemElement;
        "and-drawer": HTMLAndDrawerElement;
        "and-dropdown": HTMLAndDropdownElement;
        "and-icon": HTMLAndIconElement;
        "and-input": HTMLAndInputElement;
        "and-modal": HTMLAndModalElement;
        "and-navbar": HTMLAndNavbarElement;
        "and-pagination": HTMLAndPaginationElement;
        "and-sidebar": HTMLAndSidebarElement;
        "and-tabs": HTMLAndTabsElement;
        "and-tabs-content": HTMLAndTabsContentElement;
        "and-tabs-list": HTMLAndTabsListElement;
        "and-tabs-trigger": HTMLAndTabsTriggerElement;
        "and-toast": HTMLAndToastElement;
        "and-tooltip": HTMLAndTooltipElement;
    }
}
declare namespace LocalJSX {
    type OneOf<K extends string, T> = { [P in K]: T } | { [P in `attr:${K}`]: T } | { [P in `prop:${K}`]: T };

    /**
     * Accordion container component using headless logic
     * @example ```html
     * <and-accordion allow-multiple="true">
     *   <and-accordion-item value="item-1">
     *     <and-accordion-trigger>Item 1</and-accordion-trigger>
     *     <and-accordion-content>Content 1</and-accordion-content>
     *   </and-accordion-item>
     * </and-accordion>
     * ```
     */
    interface AndAccordion {
        /**
          * Allow multiple items to be expanded simultaneously
          * @default false
         */
        "allowMultiple"?: boolean;
        /**
          * Default expanded item values
         */
        "defaultValue"?: string[];
        /**
          * Whether the accordion is disabled
          * @default false
         */
        "disabled"?: boolean;
        /**
          * Orientation of the accordion
          * @default 'vertical'
         */
        "orientation"?: 'horizontal' | 'vertical';
    }
    /**
     * Accordion content/panel component
     */
    interface AndAccordionContent {
    }
    /**
     * Accordion item component
     */
    interface AndAccordionItem {
        /**
          * Whether this item is disabled
          * @default false
         */
        "disabled"?: boolean;
        /**
          * Unique value for this accordion item
         */
        "value": string;
    }
    /**
     * Accordion trigger/header component
     */
    interface AndAccordionTrigger {
    }
    interface AndAlert {
        /**
          * @default false
         */
        "dismissible"?: boolean;
        "onMyDismiss"?: (event: AndAlertCustomEvent<void>) => void;
        /**
          * @default 'default'
         */
        "variant"?: AlertVariant;
    }
    interface AndBadge {
        /**
          * @default 'default'
         */
        "variant"?: 'default' | 'secondary' | 'destructive' | 'outline';
    }
    interface AndButton {
        "customClass"?: string;
        /**
          * @default false
         */
        "disabled"?: boolean;
        /**
          * @default false
         */
        "loading"?: boolean;
        /**
          * @default 'default'
         */
        "size"?: ButtonProps['size'];
        /**
          * @default 'button'
         */
        "type"?: 'button' | 'submit' | 'reset';
        /**
          * @default 'default'
         */
        "variant"?: ButtonProps['variant'];
    }
    interface AndCard {
        /**
          * @default 'default'
         */
        "variant"?: 'default' | 'destructive';
    }
    interface AndCarousel {
        /**
          * @default false
         */
        "autoplay"?: boolean;
        /**
          * @default 3000
         */
        "interval"?: number;
    }
    interface AndCarouselItem {
    }
    interface AndDrawer {
        /**
          * Emitted when the drawer is closed (backdrop click, close button, or Escape).
         */
        "onMyClose"?: (event: AndDrawerCustomEvent<void>) => void;
        /**
          * Emitted when the drawer is opened.
         */
        "onMyOpen"?: (event: AndDrawerCustomEvent<void>) => void;
        /**
          * Whether the drawer is open.
          * @default false
         */
        "open"?: boolean;
        /**
          * The direction the drawer slides in from.
          * @default 'left'
         */
        "placement"?: DrawerPlacement;
        /**
          * Whether to show the default close button in the header.
          * @default true
         */
        "showClose"?: boolean;
    }
    interface AndDropdown {
        /**
          * @default true
         */
        "closeOnSelect"?: boolean;
        /**
          * @default []
         */
        "items"?: DropdownItem[];
        /**
          * @default 'Options'
         */
        "label"?: string;
        "onDropdownSelect"?: (event: AndDropdownCustomEvent<string>) => void;
        /**
          * @default 'bottom'
         */
        "placement"?: 'top' | 'bottom' | 'left' | 'right';
        /**
          * @default 'default'
         */
        "variant"?: any;
    }
    interface AndIcon {
        /**
          * The color of the icon (default: currentColor)
          * @default 'currentColor'
         */
        "color"?: string;
        /**
          * The name of the icon to render. Must be previously registered via `registerIcons()`.
         */
        "name"?: IconName;
        /**
          * The size of the icon in pixels (default: 24)
          * @default 24
         */
        "size"?: string | number;
        /**
          * Stroke width (default: 2)
          * @default 2
         */
        "strokeWidth"?: string | number;
    }
    interface AndInput {
        "class"?: string;
        /**
          * @default false
         */
        "disabled"?: boolean;
        "onMyInput"?: (event: AndInputCustomEvent<string>) => void;
        "placeholder"?: string;
        /**
          * @default 'text'
         */
        "type"?: string;
        "value"?: string;
    }
    interface AndModal {
        "onMyClose"?: (event: AndModalCustomEvent<void>) => void;
        /**
          * @default false
         */
        "open"?: boolean;
    }
    interface AndNavbar {
        /**
          * The active navigation item ID. Reflects the headless‐core state.
          * @default ''
         */
        "activeItem"?: string;
        /**
          * ARIA label for the navigation
          * @default 'Main navigation'
         */
        "ariaNavLabel"?: string;
        /**
          * Navigation items to display. When provided, the component renders its own items (with full keyboard navigation, scroll-spy, and active‐indicator). When empty, use the `nav` slot for custom content.
          * @default []
         */
        "items"?: NavItem[] | string;
        /**
          * Emitted when mobile menu state changes
         */
        "onMobileMenuChange"?: (event: AndNavbarCustomEvent<boolean>) => void;
        /**
          * Emitted when active item changes
         */
        "onNavItemClick"?: (event: AndNavbarCustomEvent<string>) => void;
        /**
          * Emitted when a navigation link is clicked
         */
        "onNavLinkClick"?: (event: AndNavbarCustomEvent<{ id: string; href: string }>) => void;
        /**
          * Positioning behaviour
          * @default 'static'
         */
        "position"?: 'static' | 'sticky' | 'fixed';
        /**
          * Enable scroll-spy (auto-detect active section by scroll position). Items must have `href` starting with `#`.
          * @default false
         */
        "scrollSpy"?: boolean;
        /**
          * Scroll-spy offset from the top of viewport (px).
          * @default 100
         */
        "scrollSpyOffset"?: number;
        /**
          * Visual variant
          * @default 'default'
         */
        "variant"?: NavbarProps['variant'];
    }
    interface AndPagination {
        /**
          * current page number
          * @default 1
         */
        "currentPage"?: number;
        /**
          * Emitted when page changes
         */
        "onPageChange"?: (event: AndPaginationCustomEvent<number>) => void;
        /**
          * total number of pages
          * @default 1
         */
        "totalPages"?: number;
    }
    interface AndSidebar {
        /**
          * The active navigation item ID
          * @default 'home'
         */
        "activeItem"?: string;
        /**
          * Whether the sidebar is collapsed
          * @default false
         */
        "collapsed"?: boolean;
        /**
          * Navigation items to display
          * @default [     { id: 'home', label: 'Home' },     { id: 'docs', label: 'Docs' },     { id: 'components', label: 'Components' },   ]
         */
        "items"?: SidebarItem[];
        /**
          * Emitted when a navigation item is clicked
         */
        "onSidebarItemClick"?: (event: AndSidebarCustomEvent<string>) => void;
        /**
          * Emitted when the sidebar collapse state changes
         */
        "onSidebarToggle"?: (event: AndSidebarCustomEvent<boolean>) => void;
        /**
          * Variant of the sidebar
          * @default 'default'
         */
        "variant"?: SidebarProps['variant'];
    }
    interface AndTabs {
        /**
          * @default 'automatic'
         */
        "activationMode"?: 'automatic' | 'manual';
        "defaultValue"?: string;
        "onValueChange"?: (event: AndTabsCustomEvent<string>) => void;
        /**
          * @default 'horizontal'
         */
        "orientation"?: 'horizontal' | 'vertical';
        "value"?: string;
    }
    interface AndTabsContent {
        /**
          * @default false
         */
        "selected"?: boolean;
        "value"?: string;
    }
    interface AndTabsList {
        /**
          * @default 'horizontal'
         */
        "orientation"?: 'horizontal' | 'vertical';
    }
    interface AndTabsTrigger {
        /**
          * @default false
         */
        "disabled"?: boolean;
        "onTabTriggerClick"?: (event: AndTabsTriggerCustomEvent<string>) => void;
        /**
          * @default false
         */
        "selected"?: boolean;
        "tabsLogic"?: TabsReturn;
        "value"?: string;
    }
    interface AndToast {
    }
    interface AndTooltip {
        /**
          * @default 0
         */
        "closeDelay"?: number;
        "content"?: string;
        /**
          * @default 0
         */
        "openDelay"?: number;
        /**
          * @default 'top'
         */
        "placement"?: TooltipPlacement;
    }

    interface AndAccordionAttributes {
        "allowMultiple": boolean;
        "orientation": 'horizontal' | 'vertical';
        "disabled": boolean;
    }
    interface AndAccordionItemAttributes {
        "value": string;
        "disabled": boolean;
    }
    interface AndAlertAttributes {
        "variant": AlertVariant;
        "dismissible": boolean;
    }
    interface AndBadgeAttributes {
        "variant": 'default' | 'secondary' | 'destructive' | 'outline';
    }
    interface AndButtonAttributes {
        "variant": ButtonProps['variant'];
        "size": ButtonProps['size'];
        "type": 'button' | 'submit' | 'reset';
        "disabled": boolean;
        "loading": boolean;
        "customClass": string;
    }
    interface AndCardAttributes {
        "variant": 'default' | 'destructive';
    }
    interface AndCarouselAttributes {
        "autoplay": boolean;
        "interval": number;
    }
    interface AndDrawerAttributes {
        "open": boolean;
        "placement": DrawerPlacement;
        "showClose": boolean;
    }
    interface AndDropdownAttributes {
        "variant": string;
        "label": string;
        "placement": 'top' | 'bottom' | 'left' | 'right';
        "closeOnSelect": boolean;
    }
    interface AndIconAttributes {
        "name": IconName;
        "size": string;
        "color": string;
        "strokeWidth": string;
    }
    interface AndInputAttributes {
        "placeholder": string;
        "value": string;
        "type": string;
        "disabled": boolean;
        "class": string;
    }
    interface AndModalAttributes {
        "open": boolean;
    }
    interface AndNavbarAttributes {
        "activeItem": string;
        "items": NavItem[] | string;
        "variant": NavbarProps['variant'];
        "position": 'static' | 'sticky' | 'fixed';
        "scrollSpy": boolean;
        "scrollSpyOffset": number;
        "ariaNavLabel": string;
    }
    interface AndPaginationAttributes {
        "totalPages": number;
        "currentPage": number;
    }
    interface AndSidebarAttributes {
        "activeItem": string;
        "collapsed": boolean;
        "variant": SidebarProps['variant'];
    }
    interface AndTabsAttributes {
        "value": string;
        "defaultValue": string;
        "orientation": 'horizontal' | 'vertical';
        "activationMode": 'automatic' | 'manual';
    }
    interface AndTabsContentAttributes {
        "value": string;
        "selected": boolean;
    }
    interface AndTabsListAttributes {
        "orientation": 'horizontal' | 'vertical';
    }
    interface AndTabsTriggerAttributes {
        "value": string;
        "disabled": boolean;
        "selected": boolean;
    }
    interface AndTooltipAttributes {
        "content": string;
        "placement": TooltipPlacement;
        "openDelay": number;
        "closeDelay": number;
    }

    interface IntrinsicElements {
        "and-accordion": Omit<AndAccordion, keyof AndAccordionAttributes> & { [K in keyof AndAccordion & keyof AndAccordionAttributes]?: AndAccordion[K] } & { [K in keyof AndAccordion & keyof AndAccordionAttributes as `attr:${K}`]?: AndAccordionAttributes[K] } & { [K in keyof AndAccordion & keyof AndAccordionAttributes as `prop:${K}`]?: AndAccordion[K] };
        "and-accordion-content": AndAccordionContent;
        "and-accordion-item": Omit<AndAccordionItem, keyof AndAccordionItemAttributes> & { [K in keyof AndAccordionItem & keyof AndAccordionItemAttributes]?: AndAccordionItem[K] } & { [K in keyof AndAccordionItem & keyof AndAccordionItemAttributes as `attr:${K}`]?: AndAccordionItemAttributes[K] } & { [K in keyof AndAccordionItem & keyof AndAccordionItemAttributes as `prop:${K}`]?: AndAccordionItem[K] } & OneOf<"value", AndAccordionItem["value"]>;
        "and-accordion-trigger": AndAccordionTrigger;
        "and-alert": Omit<AndAlert, keyof AndAlertAttributes> & { [K in keyof AndAlert & keyof AndAlertAttributes]?: AndAlert[K] } & { [K in keyof AndAlert & keyof AndAlertAttributes as `attr:${K}`]?: AndAlertAttributes[K] } & { [K in keyof AndAlert & keyof AndAlertAttributes as `prop:${K}`]?: AndAlert[K] };
        "and-badge": Omit<AndBadge, keyof AndBadgeAttributes> & { [K in keyof AndBadge & keyof AndBadgeAttributes]?: AndBadge[K] } & { [K in keyof AndBadge & keyof AndBadgeAttributes as `attr:${K}`]?: AndBadgeAttributes[K] } & { [K in keyof AndBadge & keyof AndBadgeAttributes as `prop:${K}`]?: AndBadge[K] };
        "and-button": Omit<AndButton, keyof AndButtonAttributes> & { [K in keyof AndButton & keyof AndButtonAttributes]?: AndButton[K] } & { [K in keyof AndButton & keyof AndButtonAttributes as `attr:${K}`]?: AndButtonAttributes[K] } & { [K in keyof AndButton & keyof AndButtonAttributes as `prop:${K}`]?: AndButton[K] };
        "and-card": Omit<AndCard, keyof AndCardAttributes> & { [K in keyof AndCard & keyof AndCardAttributes]?: AndCard[K] } & { [K in keyof AndCard & keyof AndCardAttributes as `attr:${K}`]?: AndCardAttributes[K] } & { [K in keyof AndCard & keyof AndCardAttributes as `prop:${K}`]?: AndCard[K] };
        "and-carousel": Omit<AndCarousel, keyof AndCarouselAttributes> & { [K in keyof AndCarousel & keyof AndCarouselAttributes]?: AndCarousel[K] } & { [K in keyof AndCarousel & keyof AndCarouselAttributes as `attr:${K}`]?: AndCarouselAttributes[K] } & { [K in keyof AndCarousel & keyof AndCarouselAttributes as `prop:${K}`]?: AndCarousel[K] };
        "and-carousel-item": AndCarouselItem;
        "and-drawer": Omit<AndDrawer, keyof AndDrawerAttributes> & { [K in keyof AndDrawer & keyof AndDrawerAttributes]?: AndDrawer[K] } & { [K in keyof AndDrawer & keyof AndDrawerAttributes as `attr:${K}`]?: AndDrawerAttributes[K] } & { [K in keyof AndDrawer & keyof AndDrawerAttributes as `prop:${K}`]?: AndDrawer[K] };
        "and-dropdown": Omit<AndDropdown, keyof AndDropdownAttributes> & { [K in keyof AndDropdown & keyof AndDropdownAttributes]?: AndDropdown[K] } & { [K in keyof AndDropdown & keyof AndDropdownAttributes as `attr:${K}`]?: AndDropdownAttributes[K] } & { [K in keyof AndDropdown & keyof AndDropdownAttributes as `prop:${K}`]?: AndDropdown[K] };
        "and-icon": Omit<AndIcon, keyof AndIconAttributes> & { [K in keyof AndIcon & keyof AndIconAttributes]?: AndIcon[K] } & { [K in keyof AndIcon & keyof AndIconAttributes as `attr:${K}`]?: AndIconAttributes[K] } & { [K in keyof AndIcon & keyof AndIconAttributes as `prop:${K}`]?: AndIcon[K] };
        "and-input": Omit<AndInput, keyof AndInputAttributes> & { [K in keyof AndInput & keyof AndInputAttributes]?: AndInput[K] } & { [K in keyof AndInput & keyof AndInputAttributes as `attr:${K}`]?: AndInputAttributes[K] } & { [K in keyof AndInput & keyof AndInputAttributes as `prop:${K}`]?: AndInput[K] };
        "and-modal": Omit<AndModal, keyof AndModalAttributes> & { [K in keyof AndModal & keyof AndModalAttributes]?: AndModal[K] } & { [K in keyof AndModal & keyof AndModalAttributes as `attr:${K}`]?: AndModalAttributes[K] } & { [K in keyof AndModal & keyof AndModalAttributes as `prop:${K}`]?: AndModal[K] };
        "and-navbar": Omit<AndNavbar, keyof AndNavbarAttributes> & { [K in keyof AndNavbar & keyof AndNavbarAttributes]?: AndNavbar[K] } & { [K in keyof AndNavbar & keyof AndNavbarAttributes as `attr:${K}`]?: AndNavbarAttributes[K] } & { [K in keyof AndNavbar & keyof AndNavbarAttributes as `prop:${K}`]?: AndNavbar[K] };
        "and-pagination": Omit<AndPagination, keyof AndPaginationAttributes> & { [K in keyof AndPagination & keyof AndPaginationAttributes]?: AndPagination[K] } & { [K in keyof AndPagination & keyof AndPaginationAttributes as `attr:${K}`]?: AndPaginationAttributes[K] } & { [K in keyof AndPagination & keyof AndPaginationAttributes as `prop:${K}`]?: AndPagination[K] };
        "and-sidebar": Omit<AndSidebar, keyof AndSidebarAttributes> & { [K in keyof AndSidebar & keyof AndSidebarAttributes]?: AndSidebar[K] } & { [K in keyof AndSidebar & keyof AndSidebarAttributes as `attr:${K}`]?: AndSidebarAttributes[K] } & { [K in keyof AndSidebar & keyof AndSidebarAttributes as `prop:${K}`]?: AndSidebar[K] };
        "and-tabs": Omit<AndTabs, keyof AndTabsAttributes> & { [K in keyof AndTabs & keyof AndTabsAttributes]?: AndTabs[K] } & { [K in keyof AndTabs & keyof AndTabsAttributes as `attr:${K}`]?: AndTabsAttributes[K] } & { [K in keyof AndTabs & keyof AndTabsAttributes as `prop:${K}`]?: AndTabs[K] };
        "and-tabs-content": Omit<AndTabsContent, keyof AndTabsContentAttributes> & { [K in keyof AndTabsContent & keyof AndTabsContentAttributes]?: AndTabsContent[K] } & { [K in keyof AndTabsContent & keyof AndTabsContentAttributes as `attr:${K}`]?: AndTabsContentAttributes[K] } & { [K in keyof AndTabsContent & keyof AndTabsContentAttributes as `prop:${K}`]?: AndTabsContent[K] };
        "and-tabs-list": Omit<AndTabsList, keyof AndTabsListAttributes> & { [K in keyof AndTabsList & keyof AndTabsListAttributes]?: AndTabsList[K] } & { [K in keyof AndTabsList & keyof AndTabsListAttributes as `attr:${K}`]?: AndTabsListAttributes[K] } & { [K in keyof AndTabsList & keyof AndTabsListAttributes as `prop:${K}`]?: AndTabsList[K] };
        "and-tabs-trigger": Omit<AndTabsTrigger, keyof AndTabsTriggerAttributes> & { [K in keyof AndTabsTrigger & keyof AndTabsTriggerAttributes]?: AndTabsTrigger[K] } & { [K in keyof AndTabsTrigger & keyof AndTabsTriggerAttributes as `attr:${K}`]?: AndTabsTriggerAttributes[K] } & { [K in keyof AndTabsTrigger & keyof AndTabsTriggerAttributes as `prop:${K}`]?: AndTabsTrigger[K] };
        "and-toast": AndToast;
        "and-tooltip": Omit<AndTooltip, keyof AndTooltipAttributes> & { [K in keyof AndTooltip & keyof AndTooltipAttributes]?: AndTooltip[K] } & { [K in keyof AndTooltip & keyof AndTooltipAttributes as `attr:${K}`]?: AndTooltipAttributes[K] } & { [K in keyof AndTooltip & keyof AndTooltipAttributes as `prop:${K}`]?: AndTooltip[K] };
    }
}
export { LocalJSX as JSX };
declare module "@stencil/core" {
    export namespace JSX {
        interface IntrinsicElements {
            /**
             * Accordion container component using headless logic
             * @example ```html
             * <and-accordion allow-multiple="true">
             *   <and-accordion-item value="item-1">
             *     <and-accordion-trigger>Item 1</and-accordion-trigger>
             *     <and-accordion-content>Content 1</and-accordion-content>
             *   </and-accordion-item>
             * </and-accordion>
             * ```
             */
            "and-accordion": LocalJSX.IntrinsicElements["and-accordion"] & JSXBase.HTMLAttributes<HTMLAndAccordionElement>;
            /**
             * Accordion content/panel component
             */
            "and-accordion-content": LocalJSX.IntrinsicElements["and-accordion-content"] & JSXBase.HTMLAttributes<HTMLAndAccordionContentElement>;
            /**
             * Accordion item component
             */
            "and-accordion-item": LocalJSX.IntrinsicElements["and-accordion-item"] & JSXBase.HTMLAttributes<HTMLAndAccordionItemElement>;
            /**
             * Accordion trigger/header component
             */
            "and-accordion-trigger": LocalJSX.IntrinsicElements["and-accordion-trigger"] & JSXBase.HTMLAttributes<HTMLAndAccordionTriggerElement>;
            "and-alert": LocalJSX.IntrinsicElements["and-alert"] & JSXBase.HTMLAttributes<HTMLAndAlertElement>;
            "and-badge": LocalJSX.IntrinsicElements["and-badge"] & JSXBase.HTMLAttributes<HTMLAndBadgeElement>;
            "and-button": LocalJSX.IntrinsicElements["and-button"] & JSXBase.HTMLAttributes<HTMLAndButtonElement>;
            "and-card": LocalJSX.IntrinsicElements["and-card"] & JSXBase.HTMLAttributes<HTMLAndCardElement>;
            "and-carousel": LocalJSX.IntrinsicElements["and-carousel"] & JSXBase.HTMLAttributes<HTMLAndCarouselElement>;
            "and-carousel-item": LocalJSX.IntrinsicElements["and-carousel-item"] & JSXBase.HTMLAttributes<HTMLAndCarouselItemElement>;
            "and-drawer": LocalJSX.IntrinsicElements["and-drawer"] & JSXBase.HTMLAttributes<HTMLAndDrawerElement>;
            "and-dropdown": LocalJSX.IntrinsicElements["and-dropdown"] & JSXBase.HTMLAttributes<HTMLAndDropdownElement>;
            "and-icon": LocalJSX.IntrinsicElements["and-icon"] & JSXBase.HTMLAttributes<HTMLAndIconElement>;
            "and-input": LocalJSX.IntrinsicElements["and-input"] & JSXBase.HTMLAttributes<HTMLAndInputElement>;
            "and-modal": LocalJSX.IntrinsicElements["and-modal"] & JSXBase.HTMLAttributes<HTMLAndModalElement>;
            "and-navbar": LocalJSX.IntrinsicElements["and-navbar"] & JSXBase.HTMLAttributes<HTMLAndNavbarElement>;
            "and-pagination": LocalJSX.IntrinsicElements["and-pagination"] & JSXBase.HTMLAttributes<HTMLAndPaginationElement>;
            "and-sidebar": LocalJSX.IntrinsicElements["and-sidebar"] & JSXBase.HTMLAttributes<HTMLAndSidebarElement>;
            "and-tabs": LocalJSX.IntrinsicElements["and-tabs"] & JSXBase.HTMLAttributes<HTMLAndTabsElement>;
            "and-tabs-content": LocalJSX.IntrinsicElements["and-tabs-content"] & JSXBase.HTMLAttributes<HTMLAndTabsContentElement>;
            "and-tabs-list": LocalJSX.IntrinsicElements["and-tabs-list"] & JSXBase.HTMLAttributes<HTMLAndTabsListElement>;
            "and-tabs-trigger": LocalJSX.IntrinsicElements["and-tabs-trigger"] & JSXBase.HTMLAttributes<HTMLAndTabsTriggerElement>;
            "and-toast": LocalJSX.IntrinsicElements["and-toast"] & JSXBase.HTMLAttributes<HTMLAndToastElement>;
            "and-tooltip": LocalJSX.IntrinsicElements["and-tooltip"] & JSXBase.HTMLAttributes<HTMLAndTooltipElement>;
        }
    }
}
