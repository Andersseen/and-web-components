/* eslint-disable */
/* tslint:disable */
/**
 * This is an autogenerated file created by the Stencil compiler.
 * It contains typing information for all components that exist in this project.
 */
import { HTMLStencilElement, JSXBase } from "@stencil/core/internal";
import { ContentItemProps } from "./components/and-accordion/and-accordion-content";
import { AccordionReturn, AlertVariant, DrawerPlacement, TabsReturn, ToastType, TooltipPlacement } from "@andersseen/headless-components";
import { TriggerItemProps } from "./components/and-accordion/and-accordion-trigger";
import { BadgeVariantProps } from "./components/and-badge/and-badge";
import { BreadcrumbVariantProps } from "./components/and-breadcrumb/and-breadcrumb";
import { BreadcrumbItemVariantProps } from "./components/and-breadcrumb/and-breadcrumb-item";
import { ButtonVariantProps } from "./components/and-button/and-button";
import { CardVariantProps } from "./components/and-card/and-card";
import { DropdownItem, DropdownPlacement, DropdownVariantProps } from "./components/and-dropdown/and-dropdown";
import { IconName } from "@andersseen/icon";
import { InputType } from "./components/and-input/and-input";
import { MenuItemVariantProps } from "./components/and-menu-list/and-menu-item";
import { NavbarProps, NavItem } from "./components/and-navbar/and-navbar";
import { SidebarItem, SidebarVariantProps } from "./components/and-sidebar/and-sidebar";
export { ContentItemProps } from "./components/and-accordion/and-accordion-content";
export { AccordionReturn, AlertVariant, DrawerPlacement, TabsReturn, ToastType, TooltipPlacement } from "@andersseen/headless-components";
export { TriggerItemProps } from "./components/and-accordion/and-accordion-trigger";
export { BadgeVariantProps } from "./components/and-badge/and-badge";
export { BreadcrumbVariantProps } from "./components/and-breadcrumb/and-breadcrumb";
export { BreadcrumbItemVariantProps } from "./components/and-breadcrumb/and-breadcrumb-item";
export { ButtonVariantProps } from "./components/and-button/and-button";
export { CardVariantProps } from "./components/and-card/and-card";
export { DropdownItem, DropdownPlacement, DropdownVariantProps } from "./components/and-dropdown/and-dropdown";
export { IconName } from "@andersseen/icon";
export { InputType } from "./components/and-input/and-input";
export { MenuItemVariantProps } from "./components/and-menu-list/and-menu-item";
export { NavbarProps, NavItem } from "./components/and-navbar/and-navbar";
export { SidebarItem, SidebarVariantProps } from "./components/and-sidebar/and-sidebar";
export namespace Components {
    /**
     * Accordion container component using headless logic.
     * @example ```html
     * <and-accordion allow-multiple="true">
     *   <and-accordion-item value="item-1">
     *     <and-accordion-trigger>Item 1</and-accordion-trigger>
     *     <and-accordion-content>Content 1</and-accordion-content>
     *   </and-accordion-item>
     * </and-accordion>
     * ```
     */
    interface AndAccordion {
        /**
          * Allow multiple items to be expanded simultaneously.
          * @default false
         */
        "allowMultiple": boolean;
        /**
          * Default expanded item values.
         */
        "defaultValue"?: string[];
        /**
          * Whether the accordion is disabled.
          * @default false
         */
        "disabled": boolean;
        /**
          * Orientation of the accordion.
          * @default 'vertical'
         */
        "orientation": 'horizontal' | 'vertical';
    }
    interface AndAccordionContent {
        /**
          * Receive item properties from parent accordion-item.
         */
        "setItemProps": (props: ContentItemProps) => Promise<void>;
    }
    /**
     * Accordion item component.
     */
    interface AndAccordionItem {
        /**
          * Whether this item is disabled.
          * @default false
         */
        "disabled": boolean;
        /**
          * Called by parent accordion to inject the headless logic.
         */
        "setAccordionLogic": (logic: AccordionReturn) => Promise<void>;
        /**
          * Unique value for this accordion item.
         */
        "value": string;
    }
    interface AndAccordionTrigger {
        /**
          * Receive item properties from parent accordion-item.
         */
        "setItemProps": (props: TriggerItemProps) => Promise<void>;
    }
    interface AndAlert {
        /**
          * Whether the alert can be dismissed.
          * @default false
         */
        "dismissible": boolean;
        /**
          * Visual variant of the alert.
          * @default 'default'
         */
        "variant": AlertVariant;
    }
    interface AndBadge {
        /**
          * Additional CSS classes from the consumer.
         */
        "customClass": string;
        /**
          * Visual variant of the badge.
          * @default 'default'
         */
        "variant": BadgeVariantProps['variant'];
    }
    interface AndBreadcrumb {
        /**
          * Additional CSS classes to merge with internal styles.
         */
        "customClass": string;
        /**
          * Size variant for the breadcrumb trail.
          * @default 'md'
         */
        "size": BreadcrumbVariantProps['size'];
    }
    interface AndBreadcrumbItem {
        /**
          * Marks this item as the current page (adds aria-current).
          * @default false
         */
        "current": boolean;
        /**
          * Additional CSS classes to merge with internal styles.
         */
        "customClass": string;
        /**
          * Hide the leading separator (typically for the first item).
          * @default false
         */
        "hideSeparator": boolean;
        /**
          * Optional URL. When set, the item renders as a link.
         */
        "href": string;
        /**
          * Size variant — should match the parent breadcrumb size.
          * @default 'md'
         */
        "size": BreadcrumbItemVariantProps['size'];
    }
    interface AndButton {
        /**
          * Additional CSS classes to merge with the internal styles.
         */
        "customClass": string;
        /**
          * Disables the button when true.
          * @default false
         */
        "disabled": boolean;
        /**
          * Shows a loading spinner and disables interaction.
          * @default false
         */
        "loading": boolean;
        /**
          * Size of the button.
          * @default 'default'
         */
        "size": ButtonVariantProps['size'];
        /**
          * HTML button type attribute.
          * @default 'button'
         */
        "type": 'button' | 'submit' | 'reset';
        /**
          * Visual variant of the button.
          * @default 'default'
         */
        "variant": ButtonVariantProps['variant'];
    }
    interface AndCard {
        /**
          * Additional CSS classes from the consumer.
         */
        "customClass": string;
        /**
          * Visual variant of the card.
          * @default 'default'
         */
        "variant": CardVariantProps['variant'];
    }
    interface AndCarousel {
        /**
          * Whether the carousel auto-advances.
          * @default false
         */
        "autoplay": boolean;
        /**
          * Interval in ms between auto-advances.
          * @default 3000
         */
        "interval": number;
        /**
          * ARIA label for the carousel region.
          * @default 'Carousel'
         */
        "label": string;
    }
    interface AndCarouselItem {
        /**
          * Accessible label for this slide.
         */
        "label": string;
    }
    interface AndContextMenu {
        /**
          * Additional CSS classes to merge with internal styles.
         */
        "customClass": string;
        /**
          * Whether the context menu is currently open (controlled).
          * @default false
         */
        "open": boolean;
    }
    interface AndDrawer {
        /**
          * Whether the drawer is open.
          * @default false
         */
        "open": boolean;
        /**
          * The direction the drawer slides in from.
          * @default 'left'
         */
        "placement": DrawerPlacement;
        /**
          * Whether to show the default close button in the header.
          * @default true
         */
        "showClose": boolean;
    }
    interface AndDropdown {
        /**
          * Whether to close the menu after an item is selected.
          * @default true
         */
        "closeOnSelect": boolean;
        /**
          * Items to render in the dropdown menu.
          * @default []
         */
        "items": DropdownItem[];
        /**
          * Accessible label for the dropdown trigger.
          * @default 'Options'
         */
        "label": string;
        /**
          * Preferred placement of the dropdown menu.
          * @default 'bottom'
         */
        "placement": DropdownPlacement;
        /**
          * Visual variant of the trigger button.
          * @default 'default'
         */
        "variant": DropdownVariantProps['variant'];
    }
    interface AndIcon {
        /**
          * The stroke/fill color (defaults to currentColor for theme inheritance).
          * @default 'currentColor'
         */
        "color": string;
        /**
          * The name of the icon to render (must be registered via `registerIcons()`).
         */
        "name": IconName;
        /**
          * The size of the icon in pixels.
          * @default 24
         */
        "size": string | number;
        /**
          * SVG stroke width.
          * @default 2
         */
        "strokeWidth": string | number;
    }
    interface AndInput {
        /**
          * Additional CSS classes from the consumer.
         */
        "customClass": string;
        /**
          * ID of the element that describes this input (e.g. error message).
         */
        "describedBy": string;
        /**
          * Disables interaction when true.
          * @default false
         */
        "disabled": boolean;
        /**
          * Whether the input is in an error state.
          * @default false
         */
        "hasError": boolean;
        /**
          * Accessible label for the input (used when no visible label exists).
         */
        "label": string;
        /**
          * Placeholder text for the input.
         */
        "placeholder": string;
        /**
          * Marks the input as required.
          * @default false
         */
        "required": boolean;
        /**
          * HTML input type.
          * @default 'text'
         */
        "type": InputType;
        /**
          * Current value of the input.
         */
        "value": string;
    }
    interface AndMenuItem {
        /**
          * Additional CSS classes to merge with internal styles.
         */
        "customClass": string;
        /**
          * Disables the menu item when true.
          * @default false
         */
        "disabled": boolean;
        /**
          * Intent variant (default or destructive).
          * @default 'default'
         */
        "intent": MenuItemVariantProps['intent'];
        /**
          * Optional value identifier for the item.
         */
        "value": string;
    }
    interface AndMenuList {
        /**
          * Accessible label for the menu.
          * @default 'Menu'
         */
        "ariaMenuLabel": string;
        /**
          * Additional CSS classes to merge with internal styles.
         */
        "customClass": string;
    }
    interface AndModal {
        /**
          * Whether the modal is open.
          * @default false
         */
        "open": boolean;
    }
    interface AndNavbar {
        /**
          * The active navigation item ID. Reflects the headless‐core state.
          * @default ''
         */
        "activeItem": string;
        /**
          * ARIA label for the navigation
          * @default 'Main navigation'
         */
        "ariaNavLabel": string;
        /**
          * Navigation items to display. When provided, the component renders its own items (with full keyboard navigation, scroll-spy, and active‐indicator). When empty, use the `nav` slot for custom content.
          * @default []
         */
        "items": NavItem[] | string;
        /**
          * Positioning behaviour
          * @default 'static'
         */
        "position": 'static' | 'sticky' | 'fixed';
        /**
          * Enable scroll-spy (auto-detect active section by scroll position). Items must have `href` starting with `#`.
          * @default false
         */
        "scrollSpy": boolean;
        /**
          * Scroll-spy offset from the top of viewport (px).
          * @default 100
         */
        "scrollSpyOffset": number;
        /**
          * Visual variant
          * @default 'default'
         */
        "variant": NavbarProps['variant'];
    }
    interface AndPagination {
        /**
          * Current active page (1-based).
          * @default 1
         */
        "currentPage": number;
        /**
          * Total number of pages.
          * @default 1
         */
        "totalPages": number;
    }
    interface AndSidebar {
        /**
          * The active navigation item ID.
          * @default 'home'
         */
        "activeItem": string;
        /**
          * Whether the sidebar is collapsed.
          * @default false
         */
        "collapsed": boolean;
        /**
          * Navigation items to display.
          * @default [     { id: 'home', label: 'Home' },     { id: 'docs', label: 'Docs' },     { id: 'components', label: 'Components' },   ]
         */
        "items": SidebarItem[];
        /**
          * Visual variant of the sidebar.
          * @default 'default'
         */
        "variant": SidebarVariantProps['variant'];
    }
    interface AndTabs {
        /**
          * How tabs are activated (on focus or on click).
          * @default 'automatic'
         */
        "activationMode": 'automatic' | 'manual';
        /**
          * The initial tab value when uncontrolled.
         */
        "defaultValue": string;
        /**
          * Orientation of the tab list.
          * @default 'horizontal'
         */
        "orientation": 'horizontal' | 'vertical';
        /**
          * The currently selected tab value.
         */
        "value": string;
    }
    interface AndTabsContent {
        /**
          * Whether this content panel is currently selected (set by parent).
          * @default false
         */
        "selected": boolean;
        /**
          * The value that identifies which tab this content belongs to.
         */
        "value": string;
    }
    interface AndTabsList {
        /**
          * Orientation of the tab list.
          * @default 'horizontal'
         */
        "orientation": 'horizontal' | 'vertical';
    }
    interface AndTabsTrigger {
        /**
          * Whether this tab trigger is disabled.
          * @default false
         */
        "disabled": boolean;
        /**
          * Whether this tab is currently selected (set by parent).
          * @default false
         */
        "selected": boolean;
        /**
          * Reference to the parent tabs headless logic (set by parent).
         */
        "tabsLogic": TabsReturn;
        /**
          * The value that identifies this tab.
         */
        "value": string;
    }
    interface AndToast {
        /**
          * Present a new toast notification.
         */
        "present": (message: string, type?: ToastType, duration?: number) => Promise<number>;
    }
    interface AndTooltip {
        /**
          * Delay in ms before hiding the tooltip.
          * @default 0
         */
        "closeDelay": number;
        /**
          * Text content of the tooltip (alternative: use the `content` slot).
         */
        "content": string;
        /**
          * Delay in ms before showing the tooltip.
          * @default 0
         */
        "openDelay": number;
        /**
          * Preferred placement of the tooltip relative to its trigger.
          * @default 'top'
         */
        "placement": TooltipPlacement;
    }
}
export interface AndAlertCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLAndAlertElement;
}
export interface AndButtonCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLAndButtonElement;
}
export interface AndCarouselCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLAndCarouselElement;
}
export interface AndContextMenuCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLAndContextMenuElement;
}
export interface AndDrawerCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLAndDrawerElement;
}
export interface AndDropdownCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLAndDropdownElement;
}
export interface AndInputCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLAndInputElement;
}
export interface AndMenuItemCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLAndMenuItemElement;
}
export interface AndModalCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLAndModalElement;
}
export interface AndNavbarCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLAndNavbarElement;
}
export interface AndPaginationCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLAndPaginationElement;
}
export interface AndSidebarCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLAndSidebarElement;
}
export interface AndTabsCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLAndTabsElement;
}
export interface AndTabsTriggerCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLAndTabsTriggerElement;
}
declare global {
    /**
     * Accordion container component using headless logic.
     * @example ```html
     * <and-accordion allow-multiple="true">
     *   <and-accordion-item value="item-1">
     *     <and-accordion-trigger>Item 1</and-accordion-trigger>
     *     <and-accordion-content>Content 1</and-accordion-content>
     *   </and-accordion-item>
     * </and-accordion>
     * ```
     */
    interface HTMLAndAccordionElement extends Components.AndAccordion, HTMLStencilElement {
    }
    var HTMLAndAccordionElement: {
        prototype: HTMLAndAccordionElement;
        new (): HTMLAndAccordionElement;
    };
    interface HTMLAndAccordionContentElement extends Components.AndAccordionContent, HTMLStencilElement {
    }
    var HTMLAndAccordionContentElement: {
        prototype: HTMLAndAccordionContentElement;
        new (): HTMLAndAccordionContentElement;
    };
    /**
     * Accordion item component.
     */
    interface HTMLAndAccordionItemElement extends Components.AndAccordionItem, HTMLStencilElement {
    }
    var HTMLAndAccordionItemElement: {
        prototype: HTMLAndAccordionItemElement;
        new (): HTMLAndAccordionItemElement;
    };
    interface HTMLAndAccordionTriggerElement extends Components.AndAccordionTrigger, HTMLStencilElement {
    }
    var HTMLAndAccordionTriggerElement: {
        prototype: HTMLAndAccordionTriggerElement;
        new (): HTMLAndAccordionTriggerElement;
    };
    interface HTMLAndAlertElementEventMap {
        "andDismiss": void;
    }
    interface HTMLAndAlertElement extends Components.AndAlert, HTMLStencilElement {
        addEventListener<K extends keyof HTMLAndAlertElementEventMap>(type: K, listener: (this: HTMLAndAlertElement, ev: AndAlertCustomEvent<HTMLAndAlertElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLAndAlertElementEventMap>(type: K, listener: (this: HTMLAndAlertElement, ev: AndAlertCustomEvent<HTMLAndAlertElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLAndAlertElement: {
        prototype: HTMLAndAlertElement;
        new (): HTMLAndAlertElement;
    };
    interface HTMLAndBadgeElement extends Components.AndBadge, HTMLStencilElement {
    }
    var HTMLAndBadgeElement: {
        prototype: HTMLAndBadgeElement;
        new (): HTMLAndBadgeElement;
    };
    interface HTMLAndBreadcrumbElement extends Components.AndBreadcrumb, HTMLStencilElement {
    }
    var HTMLAndBreadcrumbElement: {
        prototype: HTMLAndBreadcrumbElement;
        new (): HTMLAndBreadcrumbElement;
    };
    interface HTMLAndBreadcrumbItemElement extends Components.AndBreadcrumbItem, HTMLStencilElement {
    }
    var HTMLAndBreadcrumbItemElement: {
        prototype: HTMLAndBreadcrumbItemElement;
        new (): HTMLAndBreadcrumbItemElement;
    };
    interface HTMLAndButtonElementEventMap {
        "andButtonClick": MouseEvent;
    }
    interface HTMLAndButtonElement extends Components.AndButton, HTMLStencilElement {
        addEventListener<K extends keyof HTMLAndButtonElementEventMap>(type: K, listener: (this: HTMLAndButtonElement, ev: AndButtonCustomEvent<HTMLAndButtonElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLAndButtonElementEventMap>(type: K, listener: (this: HTMLAndButtonElement, ev: AndButtonCustomEvent<HTMLAndButtonElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLAndButtonElement: {
        prototype: HTMLAndButtonElement;
        new (): HTMLAndButtonElement;
    };
    interface HTMLAndCardElement extends Components.AndCard, HTMLStencilElement {
    }
    var HTMLAndCardElement: {
        prototype: HTMLAndCardElement;
        new (): HTMLAndCardElement;
    };
    interface HTMLAndCarouselElementEventMap {
        "andSlideChange": number;
    }
    interface HTMLAndCarouselElement extends Components.AndCarousel, HTMLStencilElement {
        addEventListener<K extends keyof HTMLAndCarouselElementEventMap>(type: K, listener: (this: HTMLAndCarouselElement, ev: AndCarouselCustomEvent<HTMLAndCarouselElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLAndCarouselElementEventMap>(type: K, listener: (this: HTMLAndCarouselElement, ev: AndCarouselCustomEvent<HTMLAndCarouselElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLAndCarouselElement: {
        prototype: HTMLAndCarouselElement;
        new (): HTMLAndCarouselElement;
    };
    interface HTMLAndCarouselItemElement extends Components.AndCarouselItem, HTMLStencilElement {
    }
    var HTMLAndCarouselItemElement: {
        prototype: HTMLAndCarouselItemElement;
        new (): HTMLAndCarouselItemElement;
    };
    interface HTMLAndContextMenuElementEventMap {
        "andContextMenuOpenChange": boolean;
    }
    interface HTMLAndContextMenuElement extends Components.AndContextMenu, HTMLStencilElement {
        addEventListener<K extends keyof HTMLAndContextMenuElementEventMap>(type: K, listener: (this: HTMLAndContextMenuElement, ev: AndContextMenuCustomEvent<HTMLAndContextMenuElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLAndContextMenuElementEventMap>(type: K, listener: (this: HTMLAndContextMenuElement, ev: AndContextMenuCustomEvent<HTMLAndContextMenuElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLAndContextMenuElement: {
        prototype: HTMLAndContextMenuElement;
        new (): HTMLAndContextMenuElement;
    };
    interface HTMLAndDrawerElementEventMap {
        "andDrawerClose": void;
        "andDrawerOpen": void;
    }
    interface HTMLAndDrawerElement extends Components.AndDrawer, HTMLStencilElement {
        addEventListener<K extends keyof HTMLAndDrawerElementEventMap>(type: K, listener: (this: HTMLAndDrawerElement, ev: AndDrawerCustomEvent<HTMLAndDrawerElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLAndDrawerElementEventMap>(type: K, listener: (this: HTMLAndDrawerElement, ev: AndDrawerCustomEvent<HTMLAndDrawerElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLAndDrawerElement: {
        prototype: HTMLAndDrawerElement;
        new (): HTMLAndDrawerElement;
    };
    interface HTMLAndDropdownElementEventMap {
        "andDropdownSelect": string;
        "andDropdownOpenChange": boolean;
    }
    interface HTMLAndDropdownElement extends Components.AndDropdown, HTMLStencilElement {
        addEventListener<K extends keyof HTMLAndDropdownElementEventMap>(type: K, listener: (this: HTMLAndDropdownElement, ev: AndDropdownCustomEvent<HTMLAndDropdownElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLAndDropdownElementEventMap>(type: K, listener: (this: HTMLAndDropdownElement, ev: AndDropdownCustomEvent<HTMLAndDropdownElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLAndDropdownElement: {
        prototype: HTMLAndDropdownElement;
        new (): HTMLAndDropdownElement;
    };
    interface HTMLAndIconElement extends Components.AndIcon, HTMLStencilElement {
    }
    var HTMLAndIconElement: {
        prototype: HTMLAndIconElement;
        new (): HTMLAndIconElement;
    };
    interface HTMLAndInputElementEventMap {
        "andInput": string;
        "andBlur": void;
    }
    interface HTMLAndInputElement extends Components.AndInput, HTMLStencilElement {
        addEventListener<K extends keyof HTMLAndInputElementEventMap>(type: K, listener: (this: HTMLAndInputElement, ev: AndInputCustomEvent<HTMLAndInputElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLAndInputElementEventMap>(type: K, listener: (this: HTMLAndInputElement, ev: AndInputCustomEvent<HTMLAndInputElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLAndInputElement: {
        prototype: HTMLAndInputElement;
        new (): HTMLAndInputElement;
    };
    interface HTMLAndMenuItemElementEventMap {
        "andMenuItemSelect": string;
    }
    interface HTMLAndMenuItemElement extends Components.AndMenuItem, HTMLStencilElement {
        addEventListener<K extends keyof HTMLAndMenuItemElementEventMap>(type: K, listener: (this: HTMLAndMenuItemElement, ev: AndMenuItemCustomEvent<HTMLAndMenuItemElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLAndMenuItemElementEventMap>(type: K, listener: (this: HTMLAndMenuItemElement, ev: AndMenuItemCustomEvent<HTMLAndMenuItemElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLAndMenuItemElement: {
        prototype: HTMLAndMenuItemElement;
        new (): HTMLAndMenuItemElement;
    };
    interface HTMLAndMenuListElement extends Components.AndMenuList, HTMLStencilElement {
    }
    var HTMLAndMenuListElement: {
        prototype: HTMLAndMenuListElement;
        new (): HTMLAndMenuListElement;
    };
    interface HTMLAndModalElementEventMap {
        "andClose": void;
    }
    interface HTMLAndModalElement extends Components.AndModal, HTMLStencilElement {
        addEventListener<K extends keyof HTMLAndModalElementEventMap>(type: K, listener: (this: HTMLAndModalElement, ev: AndModalCustomEvent<HTMLAndModalElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLAndModalElementEventMap>(type: K, listener: (this: HTMLAndModalElement, ev: AndModalCustomEvent<HTMLAndModalElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLAndModalElement: {
        prototype: HTMLAndModalElement;
        new (): HTMLAndModalElement;
    };
    interface HTMLAndNavbarElementEventMap {
        "navItemClick": string;
        "navLinkClick": { id: string; href: string };
        "mobileMenuChange": boolean;
    }
    interface HTMLAndNavbarElement extends Components.AndNavbar, HTMLStencilElement {
        addEventListener<K extends keyof HTMLAndNavbarElementEventMap>(type: K, listener: (this: HTMLAndNavbarElement, ev: AndNavbarCustomEvent<HTMLAndNavbarElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLAndNavbarElementEventMap>(type: K, listener: (this: HTMLAndNavbarElement, ev: AndNavbarCustomEvent<HTMLAndNavbarElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLAndNavbarElement: {
        prototype: HTMLAndNavbarElement;
        new (): HTMLAndNavbarElement;
    };
    interface HTMLAndPaginationElementEventMap {
        "andPageChange": number;
    }
    interface HTMLAndPaginationElement extends Components.AndPagination, HTMLStencilElement {
        addEventListener<K extends keyof HTMLAndPaginationElementEventMap>(type: K, listener: (this: HTMLAndPaginationElement, ev: AndPaginationCustomEvent<HTMLAndPaginationElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLAndPaginationElementEventMap>(type: K, listener: (this: HTMLAndPaginationElement, ev: AndPaginationCustomEvent<HTMLAndPaginationElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLAndPaginationElement: {
        prototype: HTMLAndPaginationElement;
        new (): HTMLAndPaginationElement;
    };
    interface HTMLAndSidebarElementEventMap {
        "andSidebarItemClick": string;
        "andSidebarToggle": boolean;
    }
    interface HTMLAndSidebarElement extends Components.AndSidebar, HTMLStencilElement {
        addEventListener<K extends keyof HTMLAndSidebarElementEventMap>(type: K, listener: (this: HTMLAndSidebarElement, ev: AndSidebarCustomEvent<HTMLAndSidebarElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLAndSidebarElementEventMap>(type: K, listener: (this: HTMLAndSidebarElement, ev: AndSidebarCustomEvent<HTMLAndSidebarElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLAndSidebarElement: {
        prototype: HTMLAndSidebarElement;
        new (): HTMLAndSidebarElement;
    };
    interface HTMLAndTabsElementEventMap {
        "andTabChange": string;
    }
    interface HTMLAndTabsElement extends Components.AndTabs, HTMLStencilElement {
        addEventListener<K extends keyof HTMLAndTabsElementEventMap>(type: K, listener: (this: HTMLAndTabsElement, ev: AndTabsCustomEvent<HTMLAndTabsElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLAndTabsElementEventMap>(type: K, listener: (this: HTMLAndTabsElement, ev: AndTabsCustomEvent<HTMLAndTabsElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLAndTabsElement: {
        prototype: HTMLAndTabsElement;
        new (): HTMLAndTabsElement;
    };
    interface HTMLAndTabsContentElement extends Components.AndTabsContent, HTMLStencilElement {
    }
    var HTMLAndTabsContentElement: {
        prototype: HTMLAndTabsContentElement;
        new (): HTMLAndTabsContentElement;
    };
    interface HTMLAndTabsListElement extends Components.AndTabsList, HTMLStencilElement {
    }
    var HTMLAndTabsListElement: {
        prototype: HTMLAndTabsListElement;
        new (): HTMLAndTabsListElement;
    };
    interface HTMLAndTabsTriggerElementEventMap {
        "tabTriggerClick": string;
    }
    interface HTMLAndTabsTriggerElement extends Components.AndTabsTrigger, HTMLStencilElement {
        addEventListener<K extends keyof HTMLAndTabsTriggerElementEventMap>(type: K, listener: (this: HTMLAndTabsTriggerElement, ev: AndTabsTriggerCustomEvent<HTMLAndTabsTriggerElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLAndTabsTriggerElementEventMap>(type: K, listener: (this: HTMLAndTabsTriggerElement, ev: AndTabsTriggerCustomEvent<HTMLAndTabsTriggerElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLAndTabsTriggerElement: {
        prototype: HTMLAndTabsTriggerElement;
        new (): HTMLAndTabsTriggerElement;
    };
    interface HTMLAndToastElement extends Components.AndToast, HTMLStencilElement {
    }
    var HTMLAndToastElement: {
        prototype: HTMLAndToastElement;
        new (): HTMLAndToastElement;
    };
    interface HTMLAndTooltipElement extends Components.AndTooltip, HTMLStencilElement {
    }
    var HTMLAndTooltipElement: {
        prototype: HTMLAndTooltipElement;
        new (): HTMLAndTooltipElement;
    };
    interface HTMLElementTagNameMap {
        "and-accordion": HTMLAndAccordionElement;
        "and-accordion-content": HTMLAndAccordionContentElement;
        "and-accordion-item": HTMLAndAccordionItemElement;
        "and-accordion-trigger": HTMLAndAccordionTriggerElement;
        "and-alert": HTMLAndAlertElement;
        "and-badge": HTMLAndBadgeElement;
        "and-breadcrumb": HTMLAndBreadcrumbElement;
        "and-breadcrumb-item": HTMLAndBreadcrumbItemElement;
        "and-button": HTMLAndButtonElement;
        "and-card": HTMLAndCardElement;
        "and-carousel": HTMLAndCarouselElement;
        "and-carousel-item": HTMLAndCarouselItemElement;
        "and-context-menu": HTMLAndContextMenuElement;
        "and-drawer": HTMLAndDrawerElement;
        "and-dropdown": HTMLAndDropdownElement;
        "and-icon": HTMLAndIconElement;
        "and-input": HTMLAndInputElement;
        "and-menu-item": HTMLAndMenuItemElement;
        "and-menu-list": HTMLAndMenuListElement;
        "and-modal": HTMLAndModalElement;
        "and-navbar": HTMLAndNavbarElement;
        "and-pagination": HTMLAndPaginationElement;
        "and-sidebar": HTMLAndSidebarElement;
        "and-tabs": HTMLAndTabsElement;
        "and-tabs-content": HTMLAndTabsContentElement;
        "and-tabs-list": HTMLAndTabsListElement;
        "and-tabs-trigger": HTMLAndTabsTriggerElement;
        "and-toast": HTMLAndToastElement;
        "and-tooltip": HTMLAndTooltipElement;
    }
}
declare namespace LocalJSX {
    type OneOf<K extends string, T> = { [P in K]: T } | { [P in `attr:${K}`]: T } | { [P in `prop:${K}`]: T };

    /**
     * Accordion container component using headless logic.
     * @example ```html
     * <and-accordion allow-multiple="true">
     *   <and-accordion-item value="item-1">
     *     <and-accordion-trigger>Item 1</and-accordion-trigger>
     *     <and-accordion-content>Content 1</and-accordion-content>
     *   </and-accordion-item>
     * </and-accordion>
     * ```
     */
    interface AndAccordion {
        /**
          * Allow multiple items to be expanded simultaneously.
          * @default false
         */
        "allowMultiple"?: boolean;
        /**
          * Default expanded item values.
         */
        "defaultValue"?: string[];
        /**
          * Whether the accordion is disabled.
          * @default false
         */
        "disabled"?: boolean;
        /**
          * Orientation of the accordion.
          * @default 'vertical'
         */
        "orientation"?: 'horizontal' | 'vertical';
    }
    interface AndAccordionContent {
    }
    /**
     * Accordion item component.
     */
    interface AndAccordionItem {
        /**
          * Whether this item is disabled.
          * @default false
         */
        "disabled"?: boolean;
        /**
          * Unique value for this accordion item.
         */
        "value": string;
    }
    interface AndAccordionTrigger {
    }
    interface AndAlert {
        /**
          * Whether the alert can be dismissed.
          * @default false
         */
        "dismissible"?: boolean;
        /**
          * Emitted when the alert is dismissed.
         */
        "onAndDismiss"?: (event: AndAlertCustomEvent<void>) => void;
        /**
          * Visual variant of the alert.
          * @default 'default'
         */
        "variant"?: AlertVariant;
    }
    interface AndBadge {
        /**
          * Additional CSS classes from the consumer.
         */
        "customClass"?: string;
        /**
          * Visual variant of the badge.
          * @default 'default'
         */
        "variant"?: BadgeVariantProps['variant'];
    }
    interface AndBreadcrumb {
        /**
          * Additional CSS classes to merge with internal styles.
         */
        "customClass"?: string;
        /**
          * Size variant for the breadcrumb trail.
          * @default 'md'
         */
        "size"?: BreadcrumbVariantProps['size'];
    }
    interface AndBreadcrumbItem {
        /**
          * Marks this item as the current page (adds aria-current).
          * @default false
         */
        "current"?: boolean;
        /**
          * Additional CSS classes to merge with internal styles.
         */
        "customClass"?: string;
        /**
          * Hide the leading separator (typically for the first item).
          * @default false
         */
        "hideSeparator"?: boolean;
        /**
          * Optional URL. When set, the item renders as a link.
         */
        "href"?: string;
        /**
          * Size variant — should match the parent breadcrumb size.
          * @default 'md'
         */
        "size"?: BreadcrumbItemVariantProps['size'];
    }
    interface AndButton {
        /**
          * Additional CSS classes to merge with the internal styles.
         */
        "customClass"?: string;
        /**
          * Disables the button when true.
          * @default false
         */
        "disabled"?: boolean;
        /**
          * Shows a loading spinner and disables interaction.
          * @default false
         */
        "loading"?: boolean;
        /**
          * Emitted on button click.
         */
        "onAndButtonClick"?: (event: AndButtonCustomEvent<MouseEvent>) => void;
        /**
          * Size of the button.
          * @default 'default'
         */
        "size"?: ButtonVariantProps['size'];
        /**
          * HTML button type attribute.
          * @default 'button'
         */
        "type"?: 'button' | 'submit' | 'reset';
        /**
          * Visual variant of the button.
          * @default 'default'
         */
        "variant"?: ButtonVariantProps['variant'];
    }
    interface AndCard {
        /**
          * Additional CSS classes from the consumer.
         */
        "customClass"?: string;
        /**
          * Visual variant of the card.
          * @default 'default'
         */
        "variant"?: CardVariantProps['variant'];
    }
    interface AndCarousel {
        /**
          * Whether the carousel auto-advances.
          * @default false
         */
        "autoplay"?: boolean;
        /**
          * Interval in ms between auto-advances.
          * @default 3000
         */
        "interval"?: number;
        /**
          * ARIA label for the carousel region.
          * @default 'Carousel'
         */
        "label"?: string;
        /**
          * Emitted when the active slide changes.
         */
        "onAndSlideChange"?: (event: AndCarouselCustomEvent<number>) => void;
    }
    interface AndCarouselItem {
        /**
          * Accessible label for this slide.
         */
        "label"?: string;
    }
    interface AndContextMenu {
        /**
          * Additional CSS classes to merge with internal styles.
         */
        "customClass"?: string;
        /**
          * Emitted when the open state changes.
         */
        "onAndContextMenuOpenChange"?: (event: AndContextMenuCustomEvent<boolean>) => void;
        /**
          * Whether the context menu is currently open (controlled).
          * @default false
         */
        "open"?: boolean;
    }
    interface AndDrawer {
        /**
          * Emitted when the drawer is closed (backdrop click, close button, or Escape).
         */
        "onAndDrawerClose"?: (event: AndDrawerCustomEvent<void>) => void;
        /**
          * Emitted when the drawer is opened.
         */
        "onAndDrawerOpen"?: (event: AndDrawerCustomEvent<void>) => void;
        /**
          * Whether the drawer is open.
          * @default false
         */
        "open"?: boolean;
        /**
          * The direction the drawer slides in from.
          * @default 'left'
         */
        "placement"?: DrawerPlacement;
        /**
          * Whether to show the default close button in the header.
          * @default true
         */
        "showClose"?: boolean;
    }
    interface AndDropdown {
        /**
          * Whether to close the menu after an item is selected.
          * @default true
         */
        "closeOnSelect"?: boolean;
        /**
          * Items to render in the dropdown menu.
          * @default []
         */
        "items"?: DropdownItem[];
        /**
          * Accessible label for the dropdown trigger.
          * @default 'Options'
         */
        "label"?: string;
        /**
          * Emitted when the dropdown open state changes.
         */
        "onAndDropdownOpenChange"?: (event: AndDropdownCustomEvent<boolean>) => void;
        /**
          * Emitted when an item is selected.
         */
        "onAndDropdownSelect"?: (event: AndDropdownCustomEvent<string>) => void;
        /**
          * Preferred placement of the dropdown menu.
          * @default 'bottom'
         */
        "placement"?: DropdownPlacement;
        /**
          * Visual variant of the trigger button.
          * @default 'default'
         */
        "variant"?: DropdownVariantProps['variant'];
    }
    interface AndIcon {
        /**
          * The stroke/fill color (defaults to currentColor for theme inheritance).
          * @default 'currentColor'
         */
        "color"?: string;
        /**
          * The name of the icon to render (must be registered via `registerIcons()`).
         */
        "name"?: IconName;
        /**
          * The size of the icon in pixels.
          * @default 24
         */
        "size"?: string | number;
        /**
          * SVG stroke width.
          * @default 2
         */
        "strokeWidth"?: string | number;
    }
    interface AndInput {
        /**
          * Additional CSS classes from the consumer.
         */
        "customClass"?: string;
        /**
          * ID of the element that describes this input (e.g. error message).
         */
        "describedBy"?: string;
        /**
          * Disables interaction when true.
          * @default false
         */
        "disabled"?: boolean;
        /**
          * Whether the input is in an error state.
          * @default false
         */
        "hasError"?: boolean;
        /**
          * Accessible label for the input (used when no visible label exists).
         */
        "label"?: string;
        /**
          * Emitted when the input loses focus.
         */
        "onAndBlur"?: (event: AndInputCustomEvent<void>) => void;
        /**
          * Emitted when the input value changes.
         */
        "onAndInput"?: (event: AndInputCustomEvent<string>) => void;
        /**
          * Placeholder text for the input.
         */
        "placeholder"?: string;
        /**
          * Marks the input as required.
          * @default false
         */
        "required"?: boolean;
        /**
          * HTML input type.
          * @default 'text'
         */
        "type"?: InputType;
        /**
          * Current value of the input.
         */
        "value"?: string;
    }
    interface AndMenuItem {
        /**
          * Additional CSS classes to merge with internal styles.
         */
        "customClass"?: string;
        /**
          * Disables the menu item when true.
          * @default false
         */
        "disabled"?: boolean;
        /**
          * Intent variant (default or destructive).
          * @default 'default'
         */
        "intent"?: MenuItemVariantProps['intent'];
        /**
          * Emitted when the item is selected (clicked or Enter/Space pressed).
         */
        "onAndMenuItemSelect"?: (event: AndMenuItemCustomEvent<string>) => void;
        /**
          * Optional value identifier for the item.
         */
        "value"?: string;
    }
    interface AndMenuList {
        /**
          * Accessible label for the menu.
          * @default 'Menu'
         */
        "ariaMenuLabel"?: string;
        /**
          * Additional CSS classes to merge with internal styles.
         */
        "customClass"?: string;
    }
    interface AndModal {
        /**
          * Emitted when the modal is closed.
         */
        "onAndClose"?: (event: AndModalCustomEvent<void>) => void;
        /**
          * Whether the modal is open.
          * @default false
         */
        "open"?: boolean;
    }
    interface AndNavbar {
        /**
          * The active navigation item ID. Reflects the headless‐core state.
          * @default ''
         */
        "activeItem"?: string;
        /**
          * ARIA label for the navigation
          * @default 'Main navigation'
         */
        "ariaNavLabel"?: string;
        /**
          * Navigation items to display. When provided, the component renders its own items (with full keyboard navigation, scroll-spy, and active‐indicator). When empty, use the `nav` slot for custom content.
          * @default []
         */
        "items"?: NavItem[] | string;
        /**
          * Emitted when mobile menu state changes
         */
        "onMobileMenuChange"?: (event: AndNavbarCustomEvent<boolean>) => void;
        /**
          * Emitted when active item changes
         */
        "onNavItemClick"?: (event: AndNavbarCustomEvent<string>) => void;
        /**
          * Emitted when a navigation link is clicked
         */
        "onNavLinkClick"?: (event: AndNavbarCustomEvent<{ id: string; href: string }>) => void;
        /**
          * Positioning behaviour
          * @default 'static'
         */
        "position"?: 'static' | 'sticky' | 'fixed';
        /**
          * Enable scroll-spy (auto-detect active section by scroll position). Items must have `href` starting with `#`.
          * @default false
         */
        "scrollSpy"?: boolean;
        /**
          * Scroll-spy offset from the top of viewport (px).
          * @default 100
         */
        "scrollSpyOffset"?: number;
        /**
          * Visual variant
          * @default 'default'
         */
        "variant"?: NavbarProps['variant'];
    }
    interface AndPagination {
        /**
          * Current active page (1-based).
          * @default 1
         */
        "currentPage"?: number;
        /**
          * Emitted when the page changes.
         */
        "onAndPageChange"?: (event: AndPaginationCustomEvent<number>) => void;
        /**
          * Total number of pages.
          * @default 1
         */
        "totalPages"?: number;
    }
    interface AndSidebar {
        /**
          * The active navigation item ID.
          * @default 'home'
         */
        "activeItem"?: string;
        /**
          * Whether the sidebar is collapsed.
          * @default false
         */
        "collapsed"?: boolean;
        /**
          * Navigation items to display.
          * @default [     { id: 'home', label: 'Home' },     { id: 'docs', label: 'Docs' },     { id: 'components', label: 'Components' },   ]
         */
        "items"?: SidebarItem[];
        /**
          * Emitted when a navigation item is clicked.
         */
        "onAndSidebarItemClick"?: (event: AndSidebarCustomEvent<string>) => void;
        /**
          * Emitted when the sidebar collapse state changes.
         */
        "onAndSidebarToggle"?: (event: AndSidebarCustomEvent<boolean>) => void;
        /**
          * Visual variant of the sidebar.
          * @default 'default'
         */
        "variant"?: SidebarVariantProps['variant'];
    }
    interface AndTabs {
        /**
          * How tabs are activated (on focus or on click).
          * @default 'automatic'
         */
        "activationMode"?: 'automatic' | 'manual';
        /**
          * The initial tab value when uncontrolled.
         */
        "defaultValue"?: string;
        /**
          * Emitted when the selected tab changes.
         */
        "onAndTabChange"?: (event: AndTabsCustomEvent<string>) => void;
        /**
          * Orientation of the tab list.
          * @default 'horizontal'
         */
        "orientation"?: 'horizontal' | 'vertical';
        /**
          * The currently selected tab value.
         */
        "value"?: string;
    }
    interface AndTabsContent {
        /**
          * Whether this content panel is currently selected (set by parent).
          * @default false
         */
        "selected"?: boolean;
        /**
          * The value that identifies which tab this content belongs to.
         */
        "value"?: string;
    }
    interface AndTabsList {
        /**
          * Orientation of the tab list.
          * @default 'horizontal'
         */
        "orientation"?: 'horizontal' | 'vertical';
    }
    interface AndTabsTrigger {
        /**
          * Whether this tab trigger is disabled.
          * @default false
         */
        "disabled"?: boolean;
        /**
          * Emitted when this trigger is clicked.
         */
        "onTabTriggerClick"?: (event: AndTabsTriggerCustomEvent<string>) => void;
        /**
          * Whether this tab is currently selected (set by parent).
          * @default false
         */
        "selected"?: boolean;
        /**
          * Reference to the parent tabs headless logic (set by parent).
         */
        "tabsLogic"?: TabsReturn;
        /**
          * The value that identifies this tab.
         */
        "value"?: string;
    }
    interface AndToast {
    }
    interface AndTooltip {
        /**
          * Delay in ms before hiding the tooltip.
          * @default 0
         */
        "closeDelay"?: number;
        /**
          * Text content of the tooltip (alternative: use the `content` slot).
         */
        "content"?: string;
        /**
          * Delay in ms before showing the tooltip.
          * @default 0
         */
        "openDelay"?: number;
        /**
          * Preferred placement of the tooltip relative to its trigger.
          * @default 'top'
         */
        "placement"?: TooltipPlacement;
    }

    interface AndAccordionAttributes {
        "allowMultiple": boolean;
        "orientation": 'horizontal' | 'vertical';
        "disabled": boolean;
    }
    interface AndAccordionItemAttributes {
        "value": string;
        "disabled": boolean;
    }
    interface AndAlertAttributes {
        "variant": AlertVariant;
        "dismissible": boolean;
    }
    interface AndBadgeAttributes {
        "variant": BadgeVariantProps['variant'];
        "customClass": string;
    }
    interface AndBreadcrumbAttributes {
        "size": BreadcrumbVariantProps['size'];
        "customClass": string;
    }
    interface AndBreadcrumbItemAttributes {
        "href": string;
        "current": boolean;
        "size": BreadcrumbItemVariantProps['size'];
        "hideSeparator": boolean;
        "customClass": string;
    }
    interface AndButtonAttributes {
        "variant": ButtonVariantProps['variant'];
        "size": ButtonVariantProps['size'];
        "type": 'button' | 'submit' | 'reset';
        "disabled": boolean;
        "loading": boolean;
        "customClass": string;
    }
    interface AndCardAttributes {
        "variant": CardVariantProps['variant'];
        "customClass": string;
    }
    interface AndCarouselAttributes {
        "autoplay": boolean;
        "interval": number;
        "label": string;
    }
    interface AndCarouselItemAttributes {
        "label": string;
    }
    interface AndContextMenuAttributes {
        "open": boolean;
        "customClass": string;
    }
    interface AndDrawerAttributes {
        "open": boolean;
        "placement": DrawerPlacement;
        "showClose": boolean;
    }
    interface AndDropdownAttributes {
        "variant": DropdownVariantProps['variant'];
        "label": string;
        "placement": DropdownPlacement;
        "closeOnSelect": boolean;
    }
    interface AndIconAttributes {
        "name": IconName;
        "size": string;
        "color": string;
        "strokeWidth": string;
    }
    interface AndInputAttributes {
        "placeholder": string;
        "value": string;
        "type": InputType;
        "disabled": boolean;
        "required": boolean;
        "hasError": boolean;
        "label": string;
        "describedBy": string;
        "customClass": string;
    }
    interface AndMenuItemAttributes {
        "intent": MenuItemVariantProps['intent'];
        "disabled": boolean;
        "value": string;
        "customClass": string;
    }
    interface AndMenuListAttributes {
        "ariaMenuLabel": string;
        "customClass": string;
    }
    interface AndModalAttributes {
        "open": boolean;
    }
    interface AndNavbarAttributes {
        "activeItem": string;
        "items": NavItem[] | string;
        "variant": NavbarProps['variant'];
        "position": 'static' | 'sticky' | 'fixed';
        "scrollSpy": boolean;
        "scrollSpyOffset": number;
        "ariaNavLabel": string;
    }
    interface AndPaginationAttributes {
        "totalPages": number;
        "currentPage": number;
    }
    interface AndSidebarAttributes {
        "activeItem": string;
        "collapsed": boolean;
        "variant": SidebarVariantProps['variant'];
    }
    interface AndTabsAttributes {
        "value": string;
        "defaultValue": string;
        "orientation": 'horizontal' | 'vertical';
        "activationMode": 'automatic' | 'manual';
    }
    interface AndTabsContentAttributes {
        "value": string;
        "selected": boolean;
    }
    interface AndTabsListAttributes {
        "orientation": 'horizontal' | 'vertical';
    }
    interface AndTabsTriggerAttributes {
        "value": string;
        "disabled": boolean;
        "selected": boolean;
    }
    interface AndTooltipAttributes {
        "content": string;
        "placement": TooltipPlacement;
        "openDelay": number;
        "closeDelay": number;
    }

    interface IntrinsicElements {
        "and-accordion": Omit<AndAccordion, keyof AndAccordionAttributes> & { [K in keyof AndAccordion & keyof AndAccordionAttributes]?: AndAccordion[K] } & { [K in keyof AndAccordion & keyof AndAccordionAttributes as `attr:${K}`]?: AndAccordionAttributes[K] } & { [K in keyof AndAccordion & keyof AndAccordionAttributes as `prop:${K}`]?: AndAccordion[K] };
        "and-accordion-content": AndAccordionContent;
        "and-accordion-item": Omit<AndAccordionItem, keyof AndAccordionItemAttributes> & { [K in keyof AndAccordionItem & keyof AndAccordionItemAttributes]?: AndAccordionItem[K] } & { [K in keyof AndAccordionItem & keyof AndAccordionItemAttributes as `attr:${K}`]?: AndAccordionItemAttributes[K] } & { [K in keyof AndAccordionItem & keyof AndAccordionItemAttributes as `prop:${K}`]?: AndAccordionItem[K] } & OneOf<"value", AndAccordionItem["value"]>;
        "and-accordion-trigger": AndAccordionTrigger;
        "and-alert": Omit<AndAlert, keyof AndAlertAttributes> & { [K in keyof AndAlert & keyof AndAlertAttributes]?: AndAlert[K] } & { [K in keyof AndAlert & keyof AndAlertAttributes as `attr:${K}`]?: AndAlertAttributes[K] } & { [K in keyof AndAlert & keyof AndAlertAttributes as `prop:${K}`]?: AndAlert[K] };
        "and-badge": Omit<AndBadge, keyof AndBadgeAttributes> & { [K in keyof AndBadge & keyof AndBadgeAttributes]?: AndBadge[K] } & { [K in keyof AndBadge & keyof AndBadgeAttributes as `attr:${K}`]?: AndBadgeAttributes[K] } & { [K in keyof AndBadge & keyof AndBadgeAttributes as `prop:${K}`]?: AndBadge[K] };
        "and-breadcrumb": Omit<AndBreadcrumb, keyof AndBreadcrumbAttributes> & { [K in keyof AndBreadcrumb & keyof AndBreadcrumbAttributes]?: AndBreadcrumb[K] } & { [K in keyof AndBreadcrumb & keyof AndBreadcrumbAttributes as `attr:${K}`]?: AndBreadcrumbAttributes[K] } & { [K in keyof AndBreadcrumb & keyof AndBreadcrumbAttributes as `prop:${K}`]?: AndBreadcrumb[K] };
        "and-breadcrumb-item": Omit<AndBreadcrumbItem, keyof AndBreadcrumbItemAttributes> & { [K in keyof AndBreadcrumbItem & keyof AndBreadcrumbItemAttributes]?: AndBreadcrumbItem[K] } & { [K in keyof AndBreadcrumbItem & keyof AndBreadcrumbItemAttributes as `attr:${K}`]?: AndBreadcrumbItemAttributes[K] } & { [K in keyof AndBreadcrumbItem & keyof AndBreadcrumbItemAttributes as `prop:${K}`]?: AndBreadcrumbItem[K] };
        "and-button": Omit<AndButton, keyof AndButtonAttributes> & { [K in keyof AndButton & keyof AndButtonAttributes]?: AndButton[K] } & { [K in keyof AndButton & keyof AndButtonAttributes as `attr:${K}`]?: AndButtonAttributes[K] } & { [K in keyof AndButton & keyof AndButtonAttributes as `prop:${K}`]?: AndButton[K] };
        "and-card": Omit<AndCard, keyof AndCardAttributes> & { [K in keyof AndCard & keyof AndCardAttributes]?: AndCard[K] } & { [K in keyof AndCard & keyof AndCardAttributes as `attr:${K}`]?: AndCardAttributes[K] } & { [K in keyof AndCard & keyof AndCardAttributes as `prop:${K}`]?: AndCard[K] };
        "and-carousel": Omit<AndCarousel, keyof AndCarouselAttributes> & { [K in keyof AndCarousel & keyof AndCarouselAttributes]?: AndCarousel[K] } & { [K in keyof AndCarousel & keyof AndCarouselAttributes as `attr:${K}`]?: AndCarouselAttributes[K] } & { [K in keyof AndCarousel & keyof AndCarouselAttributes as `prop:${K}`]?: AndCarousel[K] };
        "and-carousel-item": Omit<AndCarouselItem, keyof AndCarouselItemAttributes> & { [K in keyof AndCarouselItem & keyof AndCarouselItemAttributes]?: AndCarouselItem[K] } & { [K in keyof AndCarouselItem & keyof AndCarouselItemAttributes as `attr:${K}`]?: AndCarouselItemAttributes[K] } & { [K in keyof AndCarouselItem & keyof AndCarouselItemAttributes as `prop:${K}`]?: AndCarouselItem[K] };
        "and-context-menu": Omit<AndContextMenu, keyof AndContextMenuAttributes> & { [K in keyof AndContextMenu & keyof AndContextMenuAttributes]?: AndContextMenu[K] } & { [K in keyof AndContextMenu & keyof AndContextMenuAttributes as `attr:${K}`]?: AndContextMenuAttributes[K] } & { [K in keyof AndContextMenu & keyof AndContextMenuAttributes as `prop:${K}`]?: AndContextMenu[K] };
        "and-drawer": Omit<AndDrawer, keyof AndDrawerAttributes> & { [K in keyof AndDrawer & keyof AndDrawerAttributes]?: AndDrawer[K] } & { [K in keyof AndDrawer & keyof AndDrawerAttributes as `attr:${K}`]?: AndDrawerAttributes[K] } & { [K in keyof AndDrawer & keyof AndDrawerAttributes as `prop:${K}`]?: AndDrawer[K] };
        "and-dropdown": Omit<AndDropdown, keyof AndDropdownAttributes> & { [K in keyof AndDropdown & keyof AndDropdownAttributes]?: AndDropdown[K] } & { [K in keyof AndDropdown & keyof AndDropdownAttributes as `attr:${K}`]?: AndDropdownAttributes[K] } & { [K in keyof AndDropdown & keyof AndDropdownAttributes as `prop:${K}`]?: AndDropdown[K] };
        "and-icon": Omit<AndIcon, keyof AndIconAttributes> & { [K in keyof AndIcon & keyof AndIconAttributes]?: AndIcon[K] } & { [K in keyof AndIcon & keyof AndIconAttributes as `attr:${K}`]?: AndIconAttributes[K] } & { [K in keyof AndIcon & keyof AndIconAttributes as `prop:${K}`]?: AndIcon[K] };
        "and-input": Omit<AndInput, keyof AndInputAttributes> & { [K in keyof AndInput & keyof AndInputAttributes]?: AndInput[K] } & { [K in keyof AndInput & keyof AndInputAttributes as `attr:${K}`]?: AndInputAttributes[K] } & { [K in keyof AndInput & keyof AndInputAttributes as `prop:${K}`]?: AndInput[K] };
        "and-menu-item": Omit<AndMenuItem, keyof AndMenuItemAttributes> & { [K in keyof AndMenuItem & keyof AndMenuItemAttributes]?: AndMenuItem[K] } & { [K in keyof AndMenuItem & keyof AndMenuItemAttributes as `attr:${K}`]?: AndMenuItemAttributes[K] } & { [K in keyof AndMenuItem & keyof AndMenuItemAttributes as `prop:${K}`]?: AndMenuItem[K] };
        "and-menu-list": Omit<AndMenuList, keyof AndMenuListAttributes> & { [K in keyof AndMenuList & keyof AndMenuListAttributes]?: AndMenuList[K] } & { [K in keyof AndMenuList & keyof AndMenuListAttributes as `attr:${K}`]?: AndMenuListAttributes[K] } & { [K in keyof AndMenuList & keyof AndMenuListAttributes as `prop:${K}`]?: AndMenuList[K] };
        "and-modal": Omit<AndModal, keyof AndModalAttributes> & { [K in keyof AndModal & keyof AndModalAttributes]?: AndModal[K] } & { [K in keyof AndModal & keyof AndModalAttributes as `attr:${K}`]?: AndModalAttributes[K] } & { [K in keyof AndModal & keyof AndModalAttributes as `prop:${K}`]?: AndModal[K] };
        "and-navbar": Omit<AndNavbar, keyof AndNavbarAttributes> & { [K in keyof AndNavbar & keyof AndNavbarAttributes]?: AndNavbar[K] } & { [K in keyof AndNavbar & keyof AndNavbarAttributes as `attr:${K}`]?: AndNavbarAttributes[K] } & { [K in keyof AndNavbar & keyof AndNavbarAttributes as `prop:${K}`]?: AndNavbar[K] };
        "and-pagination": Omit<AndPagination, keyof AndPaginationAttributes> & { [K in keyof AndPagination & keyof AndPaginationAttributes]?: AndPagination[K] } & { [K in keyof AndPagination & keyof AndPaginationAttributes as `attr:${K}`]?: AndPaginationAttributes[K] } & { [K in keyof AndPagination & keyof AndPaginationAttributes as `prop:${K}`]?: AndPagination[K] };
        "and-sidebar": Omit<AndSidebar, keyof AndSidebarAttributes> & { [K in keyof AndSidebar & keyof AndSidebarAttributes]?: AndSidebar[K] } & { [K in keyof AndSidebar & keyof AndSidebarAttributes as `attr:${K}`]?: AndSidebarAttributes[K] } & { [K in keyof AndSidebar & keyof AndSidebarAttributes as `prop:${K}`]?: AndSidebar[K] };
        "and-tabs": Omit<AndTabs, keyof AndTabsAttributes> & { [K in keyof AndTabs & keyof AndTabsAttributes]?: AndTabs[K] } & { [K in keyof AndTabs & keyof AndTabsAttributes as `attr:${K}`]?: AndTabsAttributes[K] } & { [K in keyof AndTabs & keyof AndTabsAttributes as `prop:${K}`]?: AndTabs[K] };
        "and-tabs-content": Omit<AndTabsContent, keyof AndTabsContentAttributes> & { [K in keyof AndTabsContent & keyof AndTabsContentAttributes]?: AndTabsContent[K] } & { [K in keyof AndTabsContent & keyof AndTabsContentAttributes as `attr:${K}`]?: AndTabsContentAttributes[K] } & { [K in keyof AndTabsContent & keyof AndTabsContentAttributes as `prop:${K}`]?: AndTabsContent[K] };
        "and-tabs-list": Omit<AndTabsList, keyof AndTabsListAttributes> & { [K in keyof AndTabsList & keyof AndTabsListAttributes]?: AndTabsList[K] } & { [K in keyof AndTabsList & keyof AndTabsListAttributes as `attr:${K}`]?: AndTabsListAttributes[K] } & { [K in keyof AndTabsList & keyof AndTabsListAttributes as `prop:${K}`]?: AndTabsList[K] };
        "and-tabs-trigger": Omit<AndTabsTrigger, keyof AndTabsTriggerAttributes> & { [K in keyof AndTabsTrigger & keyof AndTabsTriggerAttributes]?: AndTabsTrigger[K] } & { [K in keyof AndTabsTrigger & keyof AndTabsTriggerAttributes as `attr:${K}`]?: AndTabsTriggerAttributes[K] } & { [K in keyof AndTabsTrigger & keyof AndTabsTriggerAttributes as `prop:${K}`]?: AndTabsTrigger[K] };
        "and-toast": AndToast;
        "and-tooltip": Omit<AndTooltip, keyof AndTooltipAttributes> & { [K in keyof AndTooltip & keyof AndTooltipAttributes]?: AndTooltip[K] } & { [K in keyof AndTooltip & keyof AndTooltipAttributes as `attr:${K}`]?: AndTooltipAttributes[K] } & { [K in keyof AndTooltip & keyof AndTooltipAttributes as `prop:${K}`]?: AndTooltip[K] };
    }
}
export { LocalJSX as JSX };
declare module "@stencil/core" {
    export namespace JSX {
        interface IntrinsicElements {
            /**
             * Accordion container component using headless logic.
             * @example ```html
             * <and-accordion allow-multiple="true">
             *   <and-accordion-item value="item-1">
             *     <and-accordion-trigger>Item 1</and-accordion-trigger>
             *     <and-accordion-content>Content 1</and-accordion-content>
             *   </and-accordion-item>
             * </and-accordion>
             * ```
             */
            "and-accordion": LocalJSX.IntrinsicElements["and-accordion"] & JSXBase.HTMLAttributes<HTMLAndAccordionElement>;
            "and-accordion-content": LocalJSX.IntrinsicElements["and-accordion-content"] & JSXBase.HTMLAttributes<HTMLAndAccordionContentElement>;
            /**
             * Accordion item component.
             */
            "and-accordion-item": LocalJSX.IntrinsicElements["and-accordion-item"] & JSXBase.HTMLAttributes<HTMLAndAccordionItemElement>;
            "and-accordion-trigger": LocalJSX.IntrinsicElements["and-accordion-trigger"] & JSXBase.HTMLAttributes<HTMLAndAccordionTriggerElement>;
            "and-alert": LocalJSX.IntrinsicElements["and-alert"] & JSXBase.HTMLAttributes<HTMLAndAlertElement>;
            "and-badge": LocalJSX.IntrinsicElements["and-badge"] & JSXBase.HTMLAttributes<HTMLAndBadgeElement>;
            "and-breadcrumb": LocalJSX.IntrinsicElements["and-breadcrumb"] & JSXBase.HTMLAttributes<HTMLAndBreadcrumbElement>;
            "and-breadcrumb-item": LocalJSX.IntrinsicElements["and-breadcrumb-item"] & JSXBase.HTMLAttributes<HTMLAndBreadcrumbItemElement>;
            "and-button": LocalJSX.IntrinsicElements["and-button"] & JSXBase.HTMLAttributes<HTMLAndButtonElement>;
            "and-card": LocalJSX.IntrinsicElements["and-card"] & JSXBase.HTMLAttributes<HTMLAndCardElement>;
            "and-carousel": LocalJSX.IntrinsicElements["and-carousel"] & JSXBase.HTMLAttributes<HTMLAndCarouselElement>;
            "and-carousel-item": LocalJSX.IntrinsicElements["and-carousel-item"] & JSXBase.HTMLAttributes<HTMLAndCarouselItemElement>;
            "and-context-menu": LocalJSX.IntrinsicElements["and-context-menu"] & JSXBase.HTMLAttributes<HTMLAndContextMenuElement>;
            "and-drawer": LocalJSX.IntrinsicElements["and-drawer"] & JSXBase.HTMLAttributes<HTMLAndDrawerElement>;
            "and-dropdown": LocalJSX.IntrinsicElements["and-dropdown"] & JSXBase.HTMLAttributes<HTMLAndDropdownElement>;
            "and-icon": LocalJSX.IntrinsicElements["and-icon"] & JSXBase.HTMLAttributes<HTMLAndIconElement>;
            "and-input": LocalJSX.IntrinsicElements["and-input"] & JSXBase.HTMLAttributes<HTMLAndInputElement>;
            "and-menu-item": LocalJSX.IntrinsicElements["and-menu-item"] & JSXBase.HTMLAttributes<HTMLAndMenuItemElement>;
            "and-menu-list": LocalJSX.IntrinsicElements["and-menu-list"] & JSXBase.HTMLAttributes<HTMLAndMenuListElement>;
            "and-modal": LocalJSX.IntrinsicElements["and-modal"] & JSXBase.HTMLAttributes<HTMLAndModalElement>;
            "and-navbar": LocalJSX.IntrinsicElements["and-navbar"] & JSXBase.HTMLAttributes<HTMLAndNavbarElement>;
            "and-pagination": LocalJSX.IntrinsicElements["and-pagination"] & JSXBase.HTMLAttributes<HTMLAndPaginationElement>;
            "and-sidebar": LocalJSX.IntrinsicElements["and-sidebar"] & JSXBase.HTMLAttributes<HTMLAndSidebarElement>;
            "and-tabs": LocalJSX.IntrinsicElements["and-tabs"] & JSXBase.HTMLAttributes<HTMLAndTabsElement>;
            "and-tabs-content": LocalJSX.IntrinsicElements["and-tabs-content"] & JSXBase.HTMLAttributes<HTMLAndTabsContentElement>;
            "and-tabs-list": LocalJSX.IntrinsicElements["and-tabs-list"] & JSXBase.HTMLAttributes<HTMLAndTabsListElement>;
            "and-tabs-trigger": LocalJSX.IntrinsicElements["and-tabs-trigger"] & JSXBase.HTMLAttributes<HTMLAndTabsTriggerElement>;
            "and-toast": LocalJSX.IntrinsicElements["and-toast"] & JSXBase.HTMLAttributes<HTMLAndToastElement>;
            "and-tooltip": LocalJSX.IntrinsicElements["and-tooltip"] & JSXBase.HTMLAttributes<HTMLAndTooltipElement>;
        }
    }
}
